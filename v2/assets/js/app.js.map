{"version":3,"sources":["utils.js","models.js","gui.js","jsonDataService.js","app.js","config.js","viz/legends.js","viz/paths.js","viz/viz.js","eu15a/init.js","us15a/init.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["\nfunction utils_() {\n\n  \"use strict\";\n\n  var utils = {};\n\n  /**\n   * Identity function, simply returns the first argument.\n   * @param {*} d\n   * @returns {*}\n   */\n  utils.id = function (d) { return d; }\n\n  // #############################################################################\n  // Geometric functions\n  // -----------------------------------------------------------------------------\n\n  utils.geo = {};\n\n  /** @const */\n  utils.geo._GEO_DIST_FACTOR = 360 / (6371 * 2 * Math.PI);\n\n  /**\n   * Returns the angle (in degrees) corresponding with the given displacement in km.\n   * The angle (in degrees) of a displacement of 1 km horizontally along the equator:\n   * 1 km = 1 / (2 * 6371 * pi) * 360 degrees = 0.008993216059 degrees.\n   * Inversely: 1 degree ~= 111.19492664 km\n   *\n   * @param {Number} dist The distance in km.\n   * @returns {number}\n   */\n  utils.geo.distAngle = function (dist) {\n    return dist * utils.geo._GEO_DIST_FACTOR;\n  };\n\n  /**\n   * Returns the destination location, given a start location, a bearing and a\n   * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n   * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n   * @param  {number}        bearing in degrees clockwise from north\n   * @param  {number}        distance in km\n   * @return {Array<number>} a [lon, lat] coordinate in degrees\n   */\n  utils.geo.destination = function (start, bearing, distance) {\n    var dR = distance / 6371;  // angular distance = distance / earth’s radius\n    var lat1 = utils.radians(start[1]);\n    var lon1 = utils.radians(start[0]);\n    bearing = utils.radians(bearing);\n    var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n      Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n    var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n        Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n    //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n    return [utils.degrees(lon2), utils.degrees(lat2)];\n  };\n\n  /**\n   * Returns the destination location, given a start location, a bearing and a\n   * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n   * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n   * @param  {number}        bearing in radians clockwise from north\n   * @param  {number}        distance in km\n   * @return {Array<number>} a [lon, lat] coordinate in degrees\n   */\n  utils.geo.destinationRad = function (start, bearing, distance) {\n    var dR = distance / 6371;  // angular distance = distance / earth’s radius\n    var lat1 = utils.radians(start[1]);\n    var lon1 = utils.radians(start[0]);\n    var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n      Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n    var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n        Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n    //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n    return [utils.degrees(lon2), utils.degrees(lat2)];\n  };\n\n  // #############################################################################\n  // Interpolation\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Interpolates a value in a two-dimensional domain given a set of irregularly-\n   * spaced data points. The value is interpolated by means of inverse distance\n   * weighting (Shepard, 1968)\n   *\n   * - Donald Shepard (1968) A two-dimensional interpolation function for\n   *   irregularly-spaced data. Proceedings of the 1968 23rd ACM national\n   *   conference. ACM.\n   *\n   * @param x {number} The x-coordinate of the point for which to interpolate.\n   * @param y {number} The y-coordinate of the point for which to interpolate.\n   * @param tValues {array} The known values.\n   * @param xValues {array} The x-coordinates for the known values.\n   * @param yValues {array} The y-coordinates for the known values.\n   * @param power {number} The power to use in the weighting.\n   * @returns {number} The interpolated value.\n   */\n  utils.idw = function (x, y, tValues, xValues, yValues, power) {\n    if (tValues === undefined || tValues === null) {\n      throw new Error(\"tValues is undefined in utils.idw()\");\n    }\n    if (xValues === undefined || xValues === null) {\n      throw new Error(\"xValues is undefined in utils.idw()\");\n    }\n    if (yValues === undefined || yValues === null) {\n      throw new Error(\"yValues is undefined in utils.idw()\");\n    }\n    if (tValues.length != xValues.length) {\n      throw \"tValues.length != xValues.length\";\n    }\n    if (xValues.length != yValues.length) {\n      throw \"xValues.length != yValues.length\";\n    }\n    var len = tValues.length, i, dx, dy, wi, ws = 0, r = 0;\n    for (i = 0; i < len; i++) {\n      dx = x - xValues[i];\n      dy = y - yValues[i];\n      if (dx == 0 && dy == 0) { return tValues[i]; }\n      wi = 1 / Math.pow(Math.sqrt(dx * dx + dy * dy), power);\n      r += wi * tValues[i];\n      ws += wi;\n    }\n    return r / ws;\n  };\n\n  // #############################################################################\n  // Color functions\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Transforms HSB to RGB color. Accepts either 3 arguments (hue, saturaion and\n   * value/brightness in  the range [0, 1]), or 1 argument (an object with h, s\n   * and v properties in the range [0, 1]).\n   * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   *\n   * @param   {Number|Object} h The hue value in the range [0, 1], or an\n   *                            object with three properties {h:h, s:s, v:v}.\n   * @param   {Number}        s The saturation in the range [0, 1].\n   * @param   {Number}        v The value/brightness in the range [0, 1].\n   * @returns {Object}        An object with r, g and b properties in the range\n   *                          [0, 255].\n   */\n  utils.hsvToRgb = function (h, s, v) {\n    var r, g, b, i, f, p, q, t;\n    if (h && s === undefined && v === undefined) {\n      s = h.s, v = h.v, h = h.h;\n    }\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n    }\n    return {\n      r: Math.floor(r * 255),\n      g: Math.floor(g * 255),\n      b: Math.floor(b * 255)\n    };\n  };\n\n  /**\n   * Converts an RGB color value to HSL.\n   * Assumes r, g, and b are contained in the set [0, 255] and\n   * returns h, s, and l in the set [0, 1].\n   * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * @param   {Number|Object} r The red color value in the range [0, 255], or an\n   *                            object with three properties {r:r, g:g, b:b}.\n   * @param   {Number}        g The green color value in the range [0, 255].\n   * @param   {Number}        b The blue color value in the range [0, 255].\n   * @returns {Array}         An object with h, a and v properties in the range\n   *                          [0, 1].\n   */\n  utils.rgbToHsv = function (r, g, b) {\n    var min, max, h, s, v, d;\n    if (r && g === undefined && b === undefined) {\n      g = r.g, b = r.b, r = r.r;\n    }\n    r = r / 255, g = g / 255, b = b / 255;\n    max = Math.max(r, g, b), min = Math.min(r, g, b);\n    v = max;\n    d = max - min;\n    s = max === 0 ? 0 : d / max;\n    if (max == min) {\n      h = 0; // achromatic\n    } else {\n      switch (max) {\n        case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n        case g: h = (b - r) / d + 2; break;\n        case b: h = (r - g) / d + 4; break;\n      }\n      h /= 6;\n    }\n    return {h:h, s:s, v:v};\n  };\n\n  /**\n   * Transform the given r, g and b values in the range [0, 255] to its\n   * hex-representation.\n   * @param   {Number|Object} r The red color value in the range [0, 255], or an\n   *                            object with three properties {r:r, g:g, b:b}.\n   * @param   {Number}        g The green color value in the range [0, 255].\n   * @param   {Number}        b The blue color value in the range [0, 255].\n   * @returns {String}        The hex represenation of the rgb value.\n   */\n  utils.rgbToHex = function (r, g, b) {\n    if (r && g === undefined && b === undefined) {\n      g = r.g, b = r.b, r = r.r;\n    }\n    r = r.toString(16);\n    if (r.length == 1) r = \"0\" + r;\n    g = g.toString(16);\n    if (g.length == 1) g = \"0\" + g;\n    b = b.toString(16);\n    if (b.length == 1) b = \"0\" + b;\n    return \"#\" + r + g + b;\n  };\n\n  utils.hsvToHex = function (h, s, v) {\n    return utils.rgbToHex(utils.hsvToRgb(h, s, v));\n  };\n\n  utils.hsvaToRgba = function (h, s, v, a) {\n    var rgb = utils.hsvToRgb(h, s, v);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + a + \")\";\n  };\n\n  // #############################################################################\n  // Statistics\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Returns the average of the values in the given array.\n   * @param   {Array}            ary     An array with numbers.\n   * @param   {*}                undefAv The return value when the array is empty.\n   * @returns {Number|undefined} The average or undefined if the array is empty.\n   */\n  utils.average = function (ary, undefAv) {\n    if (arguments.length === 1) { undefAv = 0; }\n    if (ary === undefined) { return undefAv; }\n    var len = ary.length;\n    if (len === 0) { return undefAv;  }\n    var r = 0;\n    for (var i = 0; i < len; i++) { r += ary[i]; }\n    return r / len;\n  };\n\n  /**\n   * Returns the average of a list of displacements, given as an array of\n   * directions and an array of corresponding speeds. These array should have\n   * the same length.\n   * @param   {Array}            angles List of angles in radias.\n   * @param   {Array}            speeds List of speeds.\n   * @param   {*}                undefAv The return value when the array is empty.\n   * @returns {Object|undefined} An object with angle and speed properties or\n   *                             undefined if the given arrays are empty.\n   */\n  utils.averageDisplacement = function (angles, speeds, undefAv) {\n    if (angles === undefined || speeds === undefined) { return undefAv; }\n    var len = angles.length;\n    if (len === 0) { return undefAv; }\n    var x = 0, y = 0;\n    for (var i = 0; i < len; i++) {\n      x += Math.cos(angles[i]) * speeds[i];\n      y += Math.sin(angles[i]) * speeds[i];\n    }\n    x /= len;\n    y /= len;\n    return {\n      angle: Math.atan2(x, y),\n      speed: Math.sqrt(x * x + y * y)\n    };\n  };\n\n  // #############################################################################\n  // Math utilities\n  // -----------------------------------------------------------------------------\n\n  utils.TWO_PI = Math.PI * 2;\n\n  /**\n   * Returns the given angle in degrees expressed as radians.\n   * @param   {Number} degrees The given angle in degrees.\n   * @returns {Number} The given angle in radians.\n   */\n  utils.radians = function (degrees) {\n    return degrees * Math.PI / 180;\n  };\n\n  /**\n   * Normalize the given angle in radians.\n   * @param angle\n   * @returns the normalized angle, i.e. 0 <= angle < Pi * 2\n   */\n  utils.normRadians = function (angle) {\n    while (angle < 0) {\n      angle += utils.TWO_PI;\n    }\n    while (angle >= utils.TWO_PI) {\n      angle -= utils.TWO_PI;\n    }\n    return angle;\n  };\n\n  utils.minimizeAngleDelta = function (count, getter, setter) {\n    if (count == 0) { return; }\n    var ac = getter(0);\n    for (var i = 1; i < count; i++) {\n      var ai = getter(i);\n      while (ai > ac + Math.PI) { ai -= utils.TWO_PI; }\n      while (ai < ac - Math.PI) { ai += utils.TWO_PI; }\n      setter(i, ai);\n      ac = ai;\n    }\n  };\n\n  /**\n   * Returns the given angle in radians expressed as degrees.\n   * @param   {Number} radians The given angle in radians.\n   * @returns {Number} The given angle in degrees.\n   */\n  utils.degrees = function (radians) {\n    return radians / Math.PI * 180;\n  };\n\n  /**\n   * Maps the value v from the source range [a, b] to the target range [c, d].\n   * @param   {Number} value The value to map.\n   * @param   {Number} low1 The first bound of the source range.\n   * @param   {Number} high1 The second bound of the source range.\n   * @param   {Number} low2 The first bound of the target range.\n   * @param   {Number} high2 The second bound of the target range.\n   * @returns {Number} The mapped value.\n   */\n  utils.mapRange = function (value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n  };\n\n  /**\n   * Constrains the given value v to the range [min, max]\n   * @param   {Number} v   The value to constrain.\n   * @param   {Number} min The minimum value of the range.\n   * @param   {Number} max The maximum value of the range.\n   * @returns {Number} The constrained value.\n   */\n  utils.constrain = function (v, min, max) {\n    if (v < min) return min;\n    else if (v > max) return max;\n    else return v;\n  };\n\n  /**\n   * Calculates the length of the vector (dx, dy).\n   * @param   {Number} dx [[Description]]\n   * @param   {Number} dy [[Description]]\n   * @returns {Number} [[Description]]\n   */\n  utils.vectorLength = function (dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  // #############################################################################\n  // Support functions\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Return the size of one em in pixels.\n   * @returns {Number} The size of one em in pixels.\n   */\n  utils.emSize = function () {\n    return parseFloat($(\"body\").css(\"font-size\"));\n  };\n\n  /**\n   * Creates a list with n zeros.\n   * @param   {Number}   length The number of zeros to\n   * @returns {[[Type]]} [[Description]]\n   */\n  utils.zeroArray = function (length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n      result.push(0);\n    }\n    return result;\n  };\n\n  // -----------------------------------------------------------------------------\n\n  utils.debug = function (name, value) {\n    //$(\"#debug\").append(\"<p>\" + name + \": \" + value + \"</p>\");\n    if (name && value === undefined) {\n      console.log(name);\n    }\n    else {\n      console.log(name + \": \" + value);\n    }\n  };\n\n  // -----------------------------------------------------------------------------\n\n  /** Polyfill String.trim for old browsers\n   *  (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */\n  if (String.prototype.trim === undefined) {\n    String.prototype.trim = function() {\n      return String(this).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    };\n  }\n\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Simple string formatting borrowed from\n   * http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format/4673436#4673436\n   * For a more advance formatter, see https://github.com/alexei/sprintf.js.\n   *\n   * Usage: \"{0} is dead, but {1} is alive! {0} {2}\".format(\"ASP\", \"ASP.NET\")\n   * >> ASP is dead, but ASP.NET is alive! ASP {2}\n   */\n  if (!String.prototype.format) {\n    String.prototype.format = function() {\n      var args = arguments;\n      return this.replace(/{(\\d+)}/g, function(match, number) {\n        return typeof args[number] != 'undefined' ? args[number] : match;\n      });\n    };\n  }\n\n  return utils;\n}\n","\"use strict\";\n\nfunction models_(_utils) {\n\n  // dependencies:\n  var utils = _utils;\n\n  // service object:\n  var models = {};\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * A caseStudy object contains all the properties provided in the metadata.json\n   * object that was use to initialize the case study. See `README.md` for more details\n   * on this metadata json format.\n   *\n   * The dataFrom, dataTill and defaultFocusFrom properties given in the metadata json,\n   * are parsed and converted to moment objects in the caseStudy object.\n   *\n   * The following properties are added in the caseStudy object:\n   * - isCaseStudy : Is true.\n   * - id : The id passed to the caseStudy constructor function.\n   * - dataService : The data-service object passed to the caseStudy constructor\n   *                 function.\n   * - dataPath : The path in which the metadata and data are found,\n   *              i.e. ./src/data/<id>/\n   * - radarCount : The number of radars.\n   * - radarIndices : A object that maps from radar ids to indices in the radars list.\n   * - radLons : An array with the longitudes of the radars, used when calling the\n   *             idw interpolation function.\n   * - radLats : An array with the latitudes of the radars, used when calling the\n   *             idw interpolation function.\n   * - anchorArea : The surface area each anchor represents, expressed in km.\n   *\n   * The following properties are added in the radar objects in the radars list:\n   * - location : An [radar.longitude, radar.latitude] array.\n   * - pixels : An object with two properties: x and y, the position of the radar\n   *            in pixel-space.\n   *\n   * Each stratum-array in the strataOptions get a third value, the height of the\n   * stratum in\n   *\n   * @param id {string} The name of the folder in /src/data/ that contains the data.\n   * @param dataService {object}\n   * @return The caseStudy object.\n   */\n  models.caseStudy = function (id, dataService) {\n\n    // caseStudy object:\n    var caseStudy = {\n      isCaseStudy: true,\n      id: id,\n      dataService: dataService\n    };\n\n    /**\n     * Asynchronously loads the case study metadata and other necessary data.\n     *\n     * @param handler {function()} Called when the laoding is complete.\n     */\n    caseStudy.load = function (handler) {\n      this.loadMetaData(function () {\n        caseStudy.dataService.initialize(caseStudy, handler);\n      });\n    };\n\n    /**\n     * @private\n     * Loads the metadata.json.\n     *\n     * @param handler {function()} Called when loading is complete.\n     */\n    caseStudy.loadMetaData = function (handler) {\n      caseStudy.dataPath = \"src/data/\" + this.id + \"/\";\n      d3.json(caseStudy.dataPath + \"metadata.json\", function (error, json) {\n        if (error) {\n          throw new Error(\"Error loading \" + caseStudy.dataPath +\n            + \"metadata.json in caseStudy.loadMetaData(). \" + error);\n        }\n\n        for (var attr in json) {\n          if (json.hasOwnProperty(attr)) { caseStudy[attr] = json[attr]; }\n        }\n        caseStudy.dataFrom = moment.utc(caseStudy.dataFrom);\n        caseStudy.dataTill = moment.utc(caseStudy.dataTill);\n        caseStudy.defaultFocusFrom = moment.utc(caseStudy.defaultFocusFrom);\n\n        caseStudy.radarCount = caseStudy.radars.length;\n        caseStudy.radarIndices = {};\n        caseStudy.radLons = [];\n        caseStudy.radLats = [];\n        caseStudy.radars.forEach(function (radar, i) {\n          radar.location = [radar.longitude, radar.latitude];\n          caseStudy.radarIndices[radar.id] = i;\n          caseStudy.radLons.push(radar.longitude);\n          caseStudy.radLats.push(radar.latitude);\n        });\n\n        caseStudy.strataOptions.forEach(function (strataOption) {\n          strataOption.forEach(function (stratum) {\n            stratum[2] = stratum[1] - stratum[0];\n          })\n        });\n\n        caseStudy.anchorArea = caseStudy.anchorInterval * caseStudy.anchorInterval;\n\n        if (caseStudy.topoJsonUrl == undefined) {\n          caseStudy.topoJsonUrl = caseStudy.dataPath + \"topo.json\";\n        }\n\n        console.info(\"Loaded case study\", caseStudy.label);\n        handler.call();\n      });\n    };\n\n    /**\n     * Loads the data for the given focus.\n     *\n     * @param focus {object} The models.focus object.\n     * @param handler {function(object)} Called when the data is loaded, passing the\n     *                data object als argument.\n     */\n    caseStudy.loadFocusData = function (focus, handler) {\n      //console.log(\">> caseStudy.loadFocusData()\");\n      this.dataService.loadFocusData(this, focus, handler);\n    };\n\n    /**\n     * @return the segment duration in milliseconds\n     */\n    caseStudy.segmentMillis = function () {\n      return this.segmentSize * 60 * 1000;\n    };\n\n    /**\n     * Initializes the d3.geo projection to be used in the mapping.\n     *\n     * @param caseStudy {object} The models.caseStudy object.\n     * @param mapWidth {number}\n     * @param mapHeight {number}\n     */\n    caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n      return d3.geo.mercator()\n        .scale(caseStudy.mapScaleFactor * mapWidth)\n        .translate([mapWidth / 2, mapHeight / 2])\n        .center(caseStudy.mapCenter);\n    };\n\n    return caseStudy;\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Creates and returns a new focus object.\n   *\n   * A focus object has the following properties:\n   * - isFocus : True.\n   * - from : A moment object that points to the start of the focus period.\n   * - till : A moment object that points to the end of the focus period.\n   * - duration : The duration of the focus period in hours.\n   * - strataOptionIdx : Identifies the currently selected strataOption, as an\n   *                     index in the caseStudy.strataOptions list.\n   * - migrantsPerPath : The number of migrants per path.\n   *\n   * @param from {moment} the start of the focus window\n   * @param duration {number} the focus duration in hours\n   * @param strataOptionIdx {number}\n   * @param migrantsPerPath {number}\n   */\n  models.focus = function (from, duration, strataOptionIdx, migrantsPerPath) {\n    var focus = {\n      from: from,\n      till: moment(from).add(duration, 'hours'),\n      duration: duration,\n      strataOptionIdx: strataOptionIdx,\n      migrantsPerPath: migrantsPerPath,\n      isFocus: true\n    };\n\n    /**\n     * @param caseStudy {object} The models.caseStudy object.\n     * @return the number of segments for the focus and the given case study\n     */\n    focus.segmentCount = function (caseStudy) {\n      return this.duration * 60 / caseStudy.segmentSize;\n    };\n\n    /**\n     * @param caseStudy {object} The models.caseStudy object.\n     * @return the strata option for the focus and the given case study\n     */\n    focus.strataOption = function (caseStudy) {\n      return caseStudy.strataOptions[this.strataOptionIdx];\n    };\n\n    /**\n     * @param caseStudy {object} The models.caseStudy object.\n     * @return the number of strata for the focus and the given case study\n     */\n    focus.strataCount = function (caseStudy) {\n      return this.strataOption(caseStudy).length;\n    };\n\n    /**\n     * Returns a list with the lowest and the highest altitude.\n     * @param caseStudy {object} The models.caseStudy object.\n     */\n    focus.altitudeRange = function (caseStudy) {\n      var strataOption = this.strataOption(caseStudy);\n      return [strataOption[0][0], strataOption[strataOption.length - 1][1]];\n    };\n\n    /**\n     * Constrains the focus period to fall within the available data period.\n     * @param caseStudy {object} The models.caseStudy object.\n     * @returns this\n     */\n    focus.constrain = function (caseStudy) {\n      if (this.from.isBefore(caseStudy.dataFrom)) {\n        this.setFrom(moment(caseStudy.dataFrom));\n      }\n      else if (this.till.isAfter(caseStudy.dataTill)) {\n        this.setTill(moment(caseStudy.dataTill));\n      }\n      return this;\n    };\n\n    /**\n     * Update the from moment and the matching till moment.\n     * @param from {moment}\n     */\n    focus.setFrom = function (from) {\n      if (this.from.isSame(from)) return;\n      this.from = from;\n      this.till = moment(from).add(this.duration, 'hours');\n    };\n\n    /**\n     * Update the till moment and the matching from moment.\n     * @param till {moment}\n     */\n    focus.setTill = function (till) {\n      if (this.till.isSame(till)) return;\n      this.till = till;\n      this.from = moment(till).subtract(this.duration, 'hours');\n    };\n\n    /**\n     * Update the duration and the derived till moment.\n     * @param duration {number} the new focus duration in hours\n     */\n    focus.setDuration = function (duration) {\n      if (this.duration == duration) return;\n      this.duration = duration;\n      this.till = moment(from).add(this.duration, 'hours');\n    };\n\n    /**\n     * @returns a clone of the focus object\n     */\n    focus.clone = function () {\n      var clone = {};\n      for (var attr in this) {\n        if (this.hasOwnProperty(attr)) { clone[attr] = this[attr]; }\n      }\n      return clone;\n    };\n\n    return focus;\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * The data structure is constructed such that it efficiently facilitates the\n   * interpolation operations needed when constructing the paths in the TIMAMP\n   * visualization.\n   *\n   * Terminology:\n   * - segment : The data is temporally segmented in segments of e.g. 20 minutes.\n   * - focus : A temporal section of the data currently shown in the visualisation.\n   * - strata : An altitude range.\n   *\n   * This data structure should always be complete, meaning that for each segment in the\n   * focus window, for each strata and for each radar, there should be a value, even\n   * if the original data does not fully cover the given focus window.\n   *\n   * The data object has the following properties:\n   * - caseStudy : The models.caseStudy for this data.\n   * - focus : The models.focus for this data.\n   * - strataOption : The strata-option used for this data.\n   * - strataCount : The number of strata in the strata-option.\n   * - segmentCount : The number of segments in the focus.\n   * - densities : An array-matrix with dimensions: [segment, strata, radar]\n   * - uSpeeds : An array-matrix with dimensions: [segment, strata, radar]\n   * - vSpeeds : An array-matrix with dimensions: [segment, strata, radar]\n   * - speeds : An array-matrix with dimensions: [segment, strata, radar]\n   * - avDensities : An array-matrix with dimensions: [strata, radar]\n   *\n   * @param caseStudy {object} The models.caseStudy object.\n   * @param focus {object} The models.focus object.\n   * @returns the data object\n   */\n  models.dataObject = function (caseStudy, focus) {\n    var dataObject = {\n      caseStudy: caseStudy,\n      focus: focus,\n      strataOption: focus.strataOption(caseStudy),\n      strataCount: focus.strataCount(caseStudy),\n      segmentCount: focus.segmentCount(caseStudy),\n      densities: [],\n      uSpeeds: [],\n      vSpeeds: [],\n      speeds: [],\n      avDensities: []\n    };\n\n    /**\n     * Initializes the empty data structure.\n     * @return the data object\n     */\n    dataObject.initStructure = function () {\n      var segn = this.segmentCount;\n      var strn = this.strataCount;\n      var radn = caseStudy.radarCount;\n      for (var segi = 0; segi < segn; segi++) {\n        var densities = [];\n        var uSpeeds = [];\n        var vSpeeds = [];\n        var speeds = [];\n        for (var stri = 0; stri < strn; stri++) {\n          densities.push(utils.zeroArray(radn));\n          uSpeeds.push(utils.zeroArray(radn));\n          vSpeeds.push(utils.zeroArray(radn));\n          speeds.push(utils.zeroArray(radn));\n        }\n        this.densities.push(densities);\n        this.uSpeeds.push(uSpeeds);\n        this.vSpeeds.push(vSpeeds);\n        this.speeds.push(speeds);\n      }\n\n      for (stri = 0; stri < strn; stri++) {\n        this.avDensities.push(utils.zeroArray(radn));\n      }\n\n      return this;\n    };\n\n    /**\n     * @param strataIdx {number}\n     * @returns {number} The size (height) of the strata with the given index.\n     */\n    dataObject.strataSize = function (strataIdx) {\n      return this.strataOption[strataIdx][2] / 1000;\n    };\n\n    /**\n     * Prepends data entries to replace missing data for a given amount of segments.\n     * @param amount {number} The number of segments for which to add data entries.\n     */\n    dataObject.prependMissingSegments = function (amount) {\n      // empty partial data structure to use in dataObject.addMissingSegments:\n      var missingSegmentData = [];\n      for (var stri = 0; stri < this.strataCount; stri++) {\n        missingSegmentData.push(utils.zeroArray(caseStudy.radarCount));\n      }\n\n      for (var i = 0; i < amount; i++) {\n        this.densities.unshift(missingSegmentData);\n        this.uSpeeds.unshift(missingSegmentData);\n        this.vSpeeds.unshift(missingSegmentData);\n        this.speeds.unshift(missingSegmentData);\n      }\n    };\n\n    /**\n     * Appends data entries to replace missing data for a given amount of segments.\n     * @param amount {number} The number of segments for which to add data entries.\n     */\n    dataObject.appendMissingSegments = function (amount) {\n      // empty partial data structure to use in dataObject.addMissingSegments:\n      var missingSegmentData = [];\n      for (var stri = 0; stri < this.strataCount; stri++) {\n        missingSegmentData.push(utils.zeroArray(caseStudy.radarCount));\n      }\n\n      for (var i = 0; i < amount; i++) {\n        this.densities.push(missingSegmentData);\n        this.uSpeeds.push(missingSegmentData);\n        this.vSpeeds.push(missingSegmentData);\n        this.speeds.push(missingSegmentData);\n      }\n    };\n\n    return dataObject;\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * This function assumes that seconds and milliseconds are zero.\n   *\n   * @param from {moment}\n   * @param focus {object} The models.focus object.\n   * @param caseStudy {object} The models.caseStudy object.\n   * @returns {moment}\n   */\n  models.constrainFrom = function (from, focus, caseStudy) {\n    if (from.isBefore(caseStudy.dataFrom)) {\n      from.date(caseStudy.dataFrom.date());\n      from.hour(caseStudy.dataFrom.hour());\n      from.minute(caseStudy.dataFrom.minute());\n      return from;\n    }\n    var till = moment(from).add(focus.duration, 'hours');\n    if (!till.isBefore(caseStudy.dataTill)) {\n      from.date(caseStudy.dataTill.date());\n      from.hour(caseStudy.dataTill.hour() - focus.duration);\n      from.minute(caseStudy.dataTill.minute());\n    }\n    return from;\n  };\n\n  return models;\n}","\"use strict\";\n\nfunction gui_(_app, _models, _config) {\n\n  // dependencies:\n  var app = _app;\n  var models = _models;\n  var config = _config;\n\n  // service object:\n  var gui = {};\n\n  /**\n   * @private\n   * Initialize the gui service.\n   */\n  gui.initialize = function () {\n    var caseStudy = app.caseStudy();\n    var focus = app.focus();\n\n    d3.select(\"#radar-anchor-radius\").text(config.radarAnchorRadius);\n    this.updateText(true);\n\n    // configure the date input widgets:\n    d3.select(\"#input-day\")\n      .property('value', focus.from.date())\n      .on('change', this.dateUpdateHandler);\n    d3.select(\"#focus-month\").text(focus.from.format(\"MMM\"));\n    d3.select(\"#focus-year\").text(focus.from.format(\"YYYY\"));\n    d3.select(\"#input-hour\")\n      .property('value', focus.from.hour())\n      .on('change', this.dateUpdateHandler);\n    \n    // configure the duration input widget:\n    d3.select(\"#input-length\")\n      .property('value', focus.duration)\n      .on('change', this.durationUpdateHandler);\n    \n    // configure the strata-count input widget:\n    d3.select(\"#input-strata\")\n      .selectAll('option')\n      .data(caseStudy.strataOptions)\n      .enter().append(\"option\")\n      .property('value', function (strataOption, i) { return i; })\n      .text(function (strataOption) { return strataOption.length; });\n    d3.select(\"#input-strata\")\n      .property('value', caseStudy.defaultStrataOption)\n      .on('change', this.strataCountUpdateHandler);\n    \n    // configure the migrants-per-path input widget:\n    d3.select(\"#input-migrants-per-path\")\n      .selectAll('option')\n      .data(config.migrantsPerPathOptions)\n      .enter().append(\"option\")\n      .property(\"value\", function (d) { return d.value; })\n      //.property(\"selected\", function(d) { return d === focus.migrantsPerPath; })\n      .text(function (d) { return d.text; });\n    d3.select(\"#input-migrants-per-path\")\n      .property('value', focus.migrantsPerPath)\n      .on('change', this.migrantsPerPathUpdateHandler);\n    \n    // set resize handler that updates the visualisation:\n    d3.select(window)\n      .on('resize', Foundation.utils.throttle(function(e) {\n        if (d3.select(\"#map-container\").node().getBoundingClientRect().width != app.mapW) {\n          app.updateVisualisation(false, true);\n        }\n      }, 25));\n  };\n\n  /**\n   * Update the text in the gui.\n   *\n   * @param migrantsPerPathChanged {boolean}\n   */\n  gui.updateText = function (migrantsPerPathChanged) {\n    var focus = app.focus();\n    if (migrantsPerPathChanged == undefined || migrantsPerPathChanged) {\n      d3.select(\"#migrants-per-path\").text(numeral(focus.migrantsPerPath).format('0,0'));\n    }\n  };\n\n  /* @private update handler. */\n  gui.dateUpdateHandler = function () {\n    //console.log(\">> gui.dateUpdateHandler\");\n    var caseStudy = app.caseStudy();\n    var focus = app.focus();\n    var inputDay = d3.select(\"#input-day\");\n    var inputHour = d3.select(\"#input-hour\");\n    \n    // derive and constrain new focus from moment:\n    var newFocusFrom = moment(focus.from);\n    newFocusFrom.date(parseInt(inputDay.property('value')));\n    newFocusFrom.hour(parseInt(inputHour.property('value')));\n    models.constrainFrom(newFocusFrom, focus, caseStudy);\n    \n    // update the input widget to the constrained values:\n    inputDay.property('value', newFocusFrom.date());\n    inputHour.property('value', newFocusFrom.hour());\n    d3.select(\"#focus-month\").text(focus.from.format(\"MMM\"));\n    d3.select(\"#focus-year\").text(focus.from.format(\"YYYY\"));\n    \n    // update focus and view if focus has changed:\n    if (!newFocusFrom.isSame(focus.from)) {\n      app.updateFocusFrom(newFocusFrom);\n    }\n  };\n\n  /* @private update handler. */\n  gui.durationUpdateHandler = function () {\n    var focus = app.focus();\n    var inputDuration = d3.select(\"#input-length\");\n    var newDuration = parseInt(inputDuration.property('value'));\n    if (newDuration != focus.duration) {\n      app.updateFocusDuration(newDuration);\n    }\n  };\n\n  /* @private update handler. */\n  gui.strataCountUpdateHandler = function () {\n    var focus = app.focus();\n    var newIdx = d3.select(\"#input-strata\").property('value');\n    if (newIdx != focus.strataOptionIdx) {\n      app.updateStrataOptionIdx(newIdx)\n    }\n  };\n\n  /* @private update handler. */\n  gui.migrantsPerPathUpdateHandler = function () {\n    var focus = app.focus();\n    var newMPP = d3.select(this).property('value');\n    if (newMPP != focus.migrantsPerPath) {\n      app.updateMigrantsPerPath(newMPP);\n      gui.updateText(focus, true);\n    }\n  };\n  \n  gui.initialize();\n\n  return gui;\n}","\"use strict\";\n\n/**\n * Data-service for models.caseStudy instances that loads data from json-files.\n *\n * @param models {object} The models service.\n */\nfunction jsonDataService(models) {\n\n  // service object:\n  var dataService = {};\n\n  // private properties:\n  var checkData = true;\n  var sourceData = null;\n  var currStrataOptionIdx = -1;\n\n  /**\n   * Initializes the dataService.\n   *\n   * @param caseStudy {object} The models.caseStudy object.\n   * @param handler {function}\n   */\n  dataService.initialize = function(caseStudy, handler) {\n    handler();\n  };\n\n  /**\n   * Loads the data for the given focus.\n   *\n   * @param caseStudy {object} The models.caseStudy object.\n   * @param focus {object} The models.focus object.\n   * @param handler {function(object)} Called when the data is loaded, passing the\n   *                data object as argument.\n   */\n  dataService.loadFocusData = function (caseStudy, focus, handler) {\n    //console.log(\">> dataService.loadFocusData()\");\n    if (currStrataOptionIdx == -1 || currStrataOptionIdx != focus.strataOptionIdx) {\n      // update source data:\n      var dataPath = caseStudy.dataPath + \"data-\" + focus.strataOptionIdx + \".json\";\n      d3.json(dataPath, function (error, json) {\n        if (error) {\n          throw new Error(\"Error in dataService.loadFocusData. \" + error);\n        }\n        sourceData = json;\n        currStrataOptionIdx = focus.strataOptionIdx;\n        dataService._loadFocusData_next(caseStudy, focus, handler);\n      });\n    }\n    else {\n      this._loadFocusData_next(caseStudy, focus, handler);\n    }\n  };\n\n  /* @private */\n  dataService._loadFocusData_next = function (caseStudy, focus, handler) {\n    var data = models.dataObject(caseStudy, focus);\n    var dt = focus.from.valueOf() - caseStudy.dataFrom.valueOf();\n    var segmentSec = caseStudy.segmentSize * 60 * 1000;\n    var iFrom = Math.floor(dt / segmentSec);\n    // add one in the following to allow for the 2-stage Runge–Kutta interpolation\n    var iTill = iFrom + data.segmentCount + 1;\n    var iMax = sourceData.densities.length;\n\n    // Warn when the focus interval does not intersect the available interval:\n    if (iFrom >= iMax) {\n      console.error(\"The focus starts after the available data interval.\");\n      data.appendMissingSegments(data.segmentCount + 1);\n      handler(data);\n      return;\n    }\n    if (iTill < 0) {\n      console.error(\"The focus end before the available data interval.\");\n      data.appendMissingSegments(data.segmentCount + 1);\n      handler(data);\n      return;\n    }\n\n    // Remember to prepend or append missing data entries:\n    var prepend = 0;\n    var append = 0;\n    if (iFrom < 0) {\n      prepend = - iFrom;\n      iFrom = 0;\n    }\n    if (iTill > iMax) {\n      append = iTill - iMax;\n      iTill = iMax;\n    }\n\n    // Use slices of the source data as focus data:\n    data.densities = sourceData.densities.slice(iFrom, iTill);\n    data.uSpeeds = sourceData.uSpeeds.slice(iFrom, iTill);\n    data.vSpeeds = sourceData.vSpeeds.slice(iFrom, iTill);\n    data.speeds = sourceData.speeds.slice(iFrom, iTill);\n\n    // Calculate average densities per radar-altitude combination, integrated\n    // over the strata height. These numbers thus represent the number of birds\n    // per square km in a given strata. The average density is calculated over\n    // the segments for which a (partial) path is shown, i.e. for which speed\n    // and density > 0.\n    var strn = data.strataCount;\n    var radn = caseStudy.radarCount;\n    var segn = data.densities.length;\n    var stri, radi, segi;\n    for (stri = 0; stri < strn; stri++) {\n      var avds = [];\n      var strataSize = data.strataSize(stri);\n      for (radi = 0; radi < radn; radi++) {\n        var cnt = 0;\n        var sum = 0;\n        for (segi = 0; segi < segn; segi++) {\n          var den = data.densities[segi][stri][radi];\n          if (den > 0 && data.speeds[segi][stri][radi] > 0) {\n            cnt++;\n            sum += den\n          }\n        }\n        if (cnt == 0) {\n          avds.push(0);\n        } else {\n          if (sum == 0) {\n            console.error(\"avDensity is zero for stri \" + stri + \" and radi \" + radi);\n          }\n          avds.push(sum / cnt * strataSize);\n        }\n      }\n      data.avDensities.push(avds);\n    }\n\n    // Prepend or append missing data:\n    if (prepend > 0) { data.prependMissingSegments(prepend); }\n    if (append > 0) { data.appendMissingSegments(append); }\n\n    if (data.densities.length != data.segmentCount + 1) {\n      throw new Error(\"The data object does not have the proper amount of \" +\n        \"entries. [data.densities.length: \" + data.densities.length +\n        \", data.segmentCount + 1: \" + (data.segmentCount + 1) + \"]\");\n    }\n\n    if (checkData) {\n      this.checkData(data);\n    }\n\n    handler(data);\n  };\n\n  /**\n   * @private\n   * Check if the given data is OK:\n   * - densities: data matrix with dimensions: [segments, strata, radars].\n   * - uSpeeds: data matrix with dimensions: [segments, strata, radars].\n   * - vSpeeds: data matrix with dimensions: [segments, strata, radars].\n   * - speeds: data matrix with dimensions: [segments, strata, radars].\n   * - avDensities: data matrix with dimensions: [strata, radars].\n   */\n  dataService.checkData = function (data) {\n    var segn = data.segmentCount + 1; // add one to allow two-phase integration\n    var strn = data.strataCount;\n    var radn = data.caseStudy.radarCount;\n    var segi, stri;\n\n    if (data.densities.length != segn) {\n      throw (\"data.densities.length (\" + data.densities.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.uSpeeds.length != segn) {\n      throw (\"data.uSpeeds.length (\" + data.uSpeeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.vSpeeds.length != segn) {\n      throw (\"data.vSpeeds.length (\" + data.vSpeeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.speeds.length != segn) {\n      throw (\"data.speeds.length (\" + data.speeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n\n    for (segi = 0; segi < segn; segi++) {\n      if (data.densities[segi].length != strn) {\n        throw (\"data.densities[segi].length (\" + data.densities[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.uSpeeds[segi].length != strn) {\n        throw (\"data.uSpeeds[segi].length (\" + data.uSpeeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.vSpeeds[segi].length != strn) {\n        throw (\"data.vSpeeds[segi].length (\" + data.vSpeeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.speeds[segi].length != strn) {\n        throw (\"data.speeds[segi].length (\" + data.speeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n\n      for (stri = 0; stri < strn; stri++) {\n        if (data.densities[segi][stri].length != radn) {\n          throw (\"data.densities[segi][stri].length (\" +\n            data.densities[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.uSpeeds[segi][stri].length != radn) {\n          throw (\"data.uSpeeds[segi][stri].length (\" +\n            data.uSpeeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.vSpeeds[segi][stri].length != radn) {\n          throw (\"data.vSpeeds[segi][stri].length (\" +\n            data.vSpeeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.speeds[segi][stri].length != radn) {\n          throw (\"data.speeds[segi][stri].length (\" +\n            data.speeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n      }\n    }\n\n    if (data.avDensities.length != strn) {\n      throw (\"data.avDensities.length (\" + data.avDensities.length +\n        \") != strn (\" + strn + \")\");\n    }\n    for (stri = 0; stri < strn; stri++) {\n      if (data.avDensities[stri].length != radn) {\n        throw (\"data.avDensities[stri].length (\" +\n          data.avDensities[stri].length + \") != radn (\" + radn + \")\");\n      }\n    }\n  };\n\n  return dataService;\n}\n","\"use strict\";\n\nfunction app(_config, _models, _viz) {\n\n  // dependencies:\n  var config = _config;\n  var models = _models;\n  var viz = _viz;\n  var gui;\n\n  // service object:\n  var app = {};\n\n  // private properties:\n  var caseStudy;\n  var focus;\n  var data;\n  var readyHandler;\n\n  /**\n   * Initialize the app.\n   *\n   * @param _caseStudy {object} The initial models.caseStudy object.\n   * @param _readyHandler {function} Called when the case-study and first data has\n   *                      been loaded and is being displayed.\n   */\n  app.initialize = function (_caseStudy, _readyHandler) {\n    readyHandler = _readyHandler;\n\n    // assert that SVG is supported by the browser:\n    if (!document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\")) {\n      app.reportError('SVG is not supported in your browser. Please use a recent browser.');\n      return;\n    }\n\n    // load the case study meta data:\n    try {\n      _caseStudy.load(function () {\n        app.caseStudy(_caseStudy); // this also initializes the _focus\n        gui = gui_(app, models, config); // initialize the gui\n        var busy = 2; // two additional asynchronous steps\n\n        // load the topography:\n        d3.json(caseStudy.topoJsonUrl, function (error, json) {\n          if (error) {\n            console.error(error);\n            return;\n          }\n          caseStudy.topoJson = json;\n\n          if (--busy == 0) {\n            app.updateVisualisation(true, true);\n          }\n        });\n\n        config.updateColors(focus.strataCount(caseStudy));\n\n        if (--busy == 0) {\n          app.updateVisualisation(true, true);\n        }\n      });\n    }\n    catch (error) {\n      app.reportError(\"Failed to initialize the app. \" + error);\n      throw error;\n    }\n\n  };\n\n  /**\n   * To call when the visualization needs to be updated.\n   *\n   * @param focusDirty\n   * @param sizeDirty\n   */\n  app.updateVisualisation = function (focusDirty, sizeDirty) {\n    //console.log(\">> app.updateVisualisation() - \" + focusDirty + \" - \" + sizeDirty);\n    var busy = 2; // two additional asynchronous steps\n\n    try {\n      if (sizeDirty) { viz.updateMapData(caseStudy); }\n\n      viz.redrawMap(caseStudy);\n\n      if (focusDirty) {\n        // A clone of the focus is passed to the loader. This focus will be set\n        // as focus property on the resulting data object.\n        var newFocus = focus.clone();\n        caseStudy.loadFocusData(newFocus, function (newData) {\n          //console.log(newData);\n          //console.log(\"- _focus == newData.focus: \" + (_focus == newData.focus));\n          if (newFocus != newData.focus) {\n            console.error(\"- newFocus == newData.focus: \" + (newFocus == newData.focus));\n            throw new Error(\"Unexpected: newFocus != newData.focus in app.updateVisualisation()\");\n          }\n          data = newData;\n          focus = data.focus;\n          viz.drawPaths(data);\n\n          if (--busy == 0 && readyHandler != undefined) {\n            readyHandler();\n            readyHandler = undefined;\n          }\n        });\n      }\n      else {\n        viz.drawPaths(data);\n      }\n\n      viz.drawLegends(caseStudy, focus);\n\n      if (--busy == 0 && readyHandler != undefined) {\n        readyHandler();\n        readyHandler = undefined;\n      }\n    }\n    catch (error) {\n      app.reportError(\"Failed to update the visualization. \" + error);\n      throw error;\n    }\n  };\n\n  /**\n   * Report an error to the user.\n   *\n   * @param msg {string} The message\n   * @param fatal {boolean} True when the error is fatal.\n   */\n  app.reportError = function (msg, fatal) {\n    // TODO: enable in production\n    console.error(msg);\n    alert(msg);\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // Accessors:\n\n  /**\n   * Get or set the caseStudy.\n   *\n   * @param newCaseStudy {object} [Optional] An models.caseStudy object.\n   */\n  app.caseStudy = function (newCaseStudy) {\n    if (newCaseStudy == undefined) { return caseStudy; }\n    caseStudy = newCaseStudy;\n\n    // initialize the initial focus:\n    focus = models.focus(\n      caseStudy.defaultFocusFrom,\n      config.defaultFocusDuration,\n      caseStudy.defaultStrataOption,\n      caseStudy.defaultMigrantsPerPath\n    );\n    focus.constrain(caseStudy);\n  };\n\n  /**\n   * Get the focus.\n   */\n  app.focus = function () {\n    return focus;\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // Focus update functions:\n\n  /**\n   * Update the focus from date.\n   *\n   * @param newFrom {moment} The new focus start moment.\n   */\n  app.updateFocusFrom = function (newFrom) {\n    focus.setFrom(newFrom);\n    this.updateVisualisation(true, false);\n  };\n\n  /**\n   * Update the focus duration.\n   *\n   * @param newDuration {number} the new focus duration in hours\n   */\n  app.updateFocusDuration = function (newDuration) {\n    focus.setDuration(newDuration);\n    this.updateVisualisation(true, false);\n  };\n\n  /**\n   * Update the focus strata-option index.\n   *\n   * @param newIdx {number} An index in the caseStudy.strataOptions array.\n   */\n  app.updateStrataOptionIdx = function (newIdx) {\n    focus.strataOptionIdx = newIdx;\n    config.updateColors(focus.strataCount(caseStudy));\n    this.updateVisualisation(true, true);\n  };\n\n  /**\n   * Update the focus migrants-per-path.\n   *\n   * @param newMPP {number}\n   */\n  app.updateMigrantsPerPath = function (newMPP) {\n    focus.migrantsPerPath = newMPP;\n    this.updateVisualisation(false, false);\n  };\n\n  return app;\n}\n\n// -----------------------------------------------------------------------------\n\n/**\n * Start the app. Call this function from a script element at the end of the html-doc.\n *\n * @param caseStudyConstructor {function()} A function that returns the (initial)\n *                             models.caseStudy object.\n */\nfunction startApp(caseStudyConstructor) {\n\n  // initialize the services:\n  var utils = utils_();\n  var config = config_(utils);\n  var models = models_(utils);\n  var viz = viz_(config, utils);\n  var _app = app(config, models, viz);\n\n  // initialize the app:\n  _app.initialize(caseStudyConstructor(models),  function () {\n    console.info(\"App ready.\")\n  });\n}\n","\"use strict\";\n\n/**\n * Configuration settings service constructor.\n *\n * @param _utils The utils service.\n */\nfunction config_(_utils) {\n\n  // dependencies:\n  var utils = _utils;\n\n  // service object:\n  var config = {};\n\n  /**\n   * The radius around radars in km in which path anchors are considered.\n   * @type {number}\n   */\n  config.radarAnchorRadius = 75;\n\n  /**\n   * The migrants-per-path options.\n   */\n  config.migrantsPerPathOptions = [\n    {value: 10000, text: \"10K\"},\n    {value: 25000, text: \"25K\"},\n    {value: 50000, text: \"50K\"},\n    {value: 100000, text: \"100K\"},\n    {value: 250000, text: \"250K\"},\n    {value: 500000, text: \"500K\"}\n  ];\n\n  /**\n   * The height of the template map divided by its width, used to obtain the actual\n   * height of the map, given the actual width after resizing.\n   * @type {number}\n   */\n  config.mapHeightFactor = 940 / 720;\n\n  /**\n   * The template legend width divided by the template map width, used to obtain the\n   * actual width of the legend, given the actual width after resizing.\n   * @type {number}\n   */\n  config.legendWidthFactor = 200 / 720;\n\n  /**\n   * The minimum value of the range of hues to pick from for strata colors.\n   * @type {number}\n   */\n  config.altiHueMin = 0.5;\n\n  /**\n   * The maximum value of the range of hues to pick from for strata colors.\n   * @type {number}\n   */\n  config.altiHueMax = 1;\n\n  /**\n   * The saturation for strata colors.\n   * @type {number}\n   */\n  config.altiSaturation = 1;\n\n  /**\n   * The brightness for strata colors.\n   * @type {number}\n   */\n  config.altiBrightness = 0.7;\n\n  /**\n   * The initial focus duration, in hours.\n   * @type {number}\n   */\n  config.defaultFocusDuration = 6;\n\n  /**\n   * When true then basic metadata is provided in the visualisation.\n   * @type {boolean}\n   */\n  config.writeMetaDataInViz = true;\n\n  /**\n   * When true the special 'arty' mode is activated.\n   * @type {boolean}\n   */\n  config.arty = false;\n\n  /**\n   * When true then the radar labels are shown.\n   * @type {boolean}\n   */\n  config.showRadarLabels = true;\n\n  /**\n   * Prepare the colors for the strata.\n   *\n   * @param strataCount {number} The number of strata.\n   */\n  config.updateColors = function (strataCount) {\n    this.altHexColors = [];\n    var hue, color;\n    if (strataCount == 1) {\n      hue = (this.altiHueMin + this.altiHueMax) / 2;\n      color = utils.hsvToHex(hue, this.altiSaturation, this.altiBrightness);\n      this.altHexColors.push(color);\n    }\n    else {\n      for (var alti = 0; alti < strataCount; alti++) {\n        hue = utils.mapRange(alti, 0, strataCount - 1, this.altiHueMin, this.altiHueMax);\n        color = utils.hsvToHex(hue, this.altiSaturation, this.altiBrightness);\n        this.altHexColors.push(color);\n      }\n    }\n  };\n\n  return config;\n}\n","\"use strict\";\n\nfunction viz_legends_(_config, _utils) {\n\n  // dependencies:\n  var config = _config;\n  var utils = _utils;\n\n  // service object:\n  var legend = {};\n\n  /**\n   * Draws the color legend in a vertical layout.\n   *\n   * @param legendG The svg group element in which to draw the legend.\n   * @param caseStudy {object} The models.caseStudy object.\n   * @param focus {object} The models.focus object.\n   */\n  legend.drawColorLegend = function (legendG, caseStudy, focus) {\n    var margin = 20;\n    var legendW = 12;\n    var legendH = 100;\n    var legendT = margin;\n\n    var altitudeRange = focus.altitudeRange(caseStudy);\n    var minHeight = altitudeRange[0] / 1000;\n    var midHeight = (altitudeRange[0] + altitudeRange[1]) / 2000;\n    var maxHeight = altitudeRange[1] / 1000;\n\n    var ty = legendT;\n    var alti, altn = focus.strataCount(caseStudy);\n    var dy = legendH / altn;\n    for (alti = altn - 1; alti >= 0; alti--) {\n      legendG.append(\"rect\")\n        .attr(\"x\", margin)\n        .attr(\"y\", ty)\n        .attr(\"width\", legendW)\n        .attr(\"height\", Math.ceil(dy))\n        .attr(\"style\", \"fill:\" + config.altHexColors[alti] + \";\");\n      ty += dy;\n    }\n\n    var lineW = 7;\n    var tx = margin + legendW + lineW;\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", margin)\n      .attr(\"y1\", legendT)\n      .attr(\"x2\", tx)\n      .attr(\"y2\", legendT);\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", margin + legendW)\n      .attr(\"y1\", legendT + legendH / 2)\n      .attr(\"x2\", tx)\n      .attr(\"y2\", legendT + legendH / 2);\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", margin)\n      .attr(\"y1\", legendT + legendH)\n      .attr(\"x2\", tx)\n      .attr(\"y2\", legendT + legendH);\n\n    tx = margin + legendW + lineW + 4;\n    legendG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", tx)\n      .attr(\"y\", legendT + 8)\n      .text(maxHeight + \"km\");\n    legendG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", tx)\n      .attr(\"y\", legendT + legendH / 2 + 4)\n      .text(midHeight + \" km\");\n    legendG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", tx)\n      .attr(\"y\", legendT + legendH)\n      .text(minHeight + \" km\");\n    legendG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin + legendW + lineW + 2)\n      .attr(\"y\", legendT + legendH + 12)\n      .text(\"altitude\");\n  };\n\n  /**\n   * Draws the scale legend.\n   *\n   * @param legendG The svg group element in which to draw the legend.\n   * @param mapW {number} map width\n   * @param mapH {number} map height\n   * @param projection {object} The d3.geo projection used to draw the map.\n   * @param caseStudy {object} The models.caseStudy object.\n   */\n  legend.drawScaleLegend = function (legendG, mapW, mapH, projection, caseStudy) {\n    var markers = caseStudy.scaleLegendMarkers\n    var totalKm = markers[2];\n    var radar = caseStudy.radars[0];\n    var destProj = projection(utils.geo.destination(radar.location, 90, totalKm));\n    var legendW = destProj[0] - projection(radar.location)[0];\n    var marginR = 45;\n    var legendL = mapW - marginR - legendW;\n    var legendR = mapW - marginR;\n    var lineH = 7;\n    var ty = mapH - 20 - lineH - 4;\n\n    var markerGr = legendG.append(\"g\");\n    markerGr.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", legendL)\n      .attr(\"y\", ty)\n      .attr(\"text-anchor\", \"middle\")\n      .text(\"0\");\n    markerGr.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", (legendL + legendR) / 2)\n      .attr(\"y\", ty)\n      .attr(\"text-anchor\", \"middle\")\n      .text(markers[1]);\n    markerGr.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", legendR + 8)\n      .attr(\"y\", ty)\n      .attr(\"text-anchor\", \"middle\")\n      .text(markers[2] + \" km\");\n\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", legendL)\n      .attr(\"y1\", mapH - 20)\n      .attr(\"x2\", legendR)\n      .attr(\"y2\", mapH - 20);\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", legendL)\n      .attr(\"y1\", mapH - 20 - lineH)\n      .attr(\"x2\", legendL)\n      .attr(\"y2\", mapH - 20);\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", (legendL + legendR) / 2)\n      .attr(\"y1\", mapH - 20 - lineH)\n      .attr(\"x2\", (legendL + legendR) / 2)\n      .attr(\"y2\", mapH - 20);\n    legendG.append(\"line\")\n      .classed(\"scale-legend-line\", true)\n      .attr(\"x1\", legendR)\n      .attr(\"y1\", mapH - 20 - lineH)\n      .attr(\"x2\", legendR)\n      .attr(\"y2\", mapH - 20);\n  };\n\n  /**\n   * @param mdG {object} The svg group element in which to draw the meta data text.\n   * @param mapH {number} Map height.\n   * @param focus {object} The models.focus object.\n   */\n  legend.writeMetaData = function (mdG, mapH, focus) {\n    var margin = 18;\n    var lh = 12;\n    var ly = mapH - 7 - 3 * lh;\n    var formatString = \"HH[h], MMM D, YYYY\";\n    var tillMoment = moment(focus.from).add(focus.duration, \"hours\");\n\n    mdG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin)\n      .attr(\"y\", ly)\n      .text(\"From:\");\n    mdG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin + 35)\n      .attr(\"y\", ly)\n      .text(focus.from.format(formatString));\n\n    ly += lh;\n    mdG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin)\n      .attr(\"y\", ly)\n      .text(\"Till:\");\n    mdG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin + 35)\n      .attr(\"y\", ly)\n      .text(tillMoment.format(formatString));\n\n    ly += lh;\n    mdG.append(\"text\")\n      .classed(\"legend-label\", true)\n      .attr(\"x\", margin)\n      .attr(\"y\", ly)\n      .text(\"Migrants per line: \" + focus.migrantsPerPath);\n  };\n\n  return legend;\n}\n","\"use strict\";\n\nfunction viz_paths_(_config, _utils) {\n\n  // dependencies:\n  var config = _config;\n  var utils = _utils;\n\n  // service object:\n  var paths = {};\n\n  // private properties:\n  var radiusFactor = 0.05;  // Determines the thickness of the paths.\n\n  // pathData indices:\n  var pdi_x = 0;\n  var pdi_y = 1;\n  var pdi_density = 2;\n  var pdi_angle = 3;\n  var pdi_location = 4;\n  var pdi_distance = 5;\n\n  /**\n   * Draw the paths.\n   *\n   * @param data {object} the models.dataObject\n   * @param anchorLocations {array} the anchor locations\n   * @param projection {function} the d3.geo geographic projection\n   * @param pathsG {object} The svg group element in which to draw the paths.\n   */\n  paths.drawPaths = function (data, anchorLocations, projection, pathsG) {\n    //console.log(\">> _paths.drawPaths\");\n\n    // set fixed random seed:\n    Math.seedrandom('ENRAM');\n\n    var rlons = data.caseStudy.radLons;\n    var rlats = data.caseStudy.radLats;\n    var idw = utils.idw;\n    var strn = data.strataCount;\n    var probf = data.caseStudy.anchorArea / data.focus.migrantsPerPath;\n    for (var stri = 0; stri < strn; stri++) {\n      try {\n        var densities = data.avDensities[stri]; // birds/km2 in the strata\n      }\n      catch (error) {\n        console.error(\"- stri: \" + stri);\n        console.error(\"- strn: \" + strn);\n        console.error(\"- data.avDensities: \" + data.avDensities);\n        throw (error);\n      }\n\n      var pathColor = config.altHexColors[stri];\n\n      anchorLocations.forEach(function (anchorLoc) {\n        try {\n          var density = idw(anchorLoc[0], anchorLoc[1], densities, rlons, rlats, 2);\n        }\n        catch (error) {\n          console.error(\"- anchorLoc: \" + anchorLoc);\n          throw (error);\n        }\n\n        // Only continue for a subset of anchor locations, selected by a probability based\n        // on the average density:\n        if (Math.random() < density * probf) {\n          //console.log(\"- active anchorId(anchorLoc): \" + anchorId(anchorLoc));\n\n          var pathData = paths.buildPathData(data, stri, anchorLoc, projection);\n          if (pathData.length == 0) {\n            //console.log(\"got empty pathData\");\n            return;\n          }\n\n          var lineData = paths.buildOutline(pathData);\n          var flowG = pathsG.append(\"g\").classed(\"flow-line\", true);\n          paths.drawPath(flowG, pathData, lineData, pathColor);\n\n          // DEBUG:\n          //if (isDebug(anchorLoc)) {\n          //  console.log(pathData);\n          //  flowG.select(\"path\").style(\"fill\", \"#f00\");\n          //}\n        }\n      });\n    }\n  };\n\n  /**\n   * @private\n   * The resulting path is obtained through numerical integration from the anchor point, half\n   * backwards, half forwards. The integration is implemented using the 2-stage Runge–Kutta\n   * algorithm, also known as the Heun method, as represented in the following scheme:\n   *\n   *        a := k.u(p_i, t_i),\n   *        b := k.u(p_i + a, t_i + k)\n   *  p_(i+1) := p_i + 1/2(a + b)\n   *\n   * where:\n   * -       i : the current iteration index\n   * -     p_i : the position at index i\n   * -     t_i : the time at index i\n   * - u(x, t) : the velocity at position x and time t\n   * -       k : timestep\n   *\n   * Reference: Darmofal_96a (in README.md)\n   *\n   * @param data {object} the models.dataObject\n   * @param stri {number} strata index\n   * @param anchorLoc {array} Anchor location in the form of a [longitude, latitude] array.\n   * @param projection {function} The d3.geo projection.\n   */\n  paths.buildPathData = function (data, stri, anchorLoc, projection) {\n    var pathData = [];\n    var rlons = data.caseStudy.radLons;\n    var rlats = data.caseStudy.radLats;\n    var idw = utils.idw;\n\n    // This value is multiplied with uSpeed/vSpeed values, expressed in m/s, in order\n    // to obtain the distance traveled during the segment interval, expressed in km.\n    // Note: data.caseStudy.segmentSize = the duration of a segment in minutes (e.g. 20 min).\n    var tf1 = data.caseStudy.segmentSize * 60 / 1000;\n\n    /**\n     * @param p_0 {array} source position as [longitude, latitude] array\n     * @param t_i {number} source segment index\n     * @param s_i {number} strata index\n     */\n    function stepBackward(p_0, t_i, s_i) {\n      var a_u = -idw(p_0[0], p_0[1], data.uSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      var a_v = -idw(p_0[0], p_0[1], data.vSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      var a_d = utils.vectorLength(a_u, a_v);  // distance a\n      var a_a = Math.atan2(a_u, a_v);         // angle a\n      var a_l = utils.geo.destinationRad(p_0, a_a, a_d);  // location p_0 + a\n      var b_u = -idw(a_l[0], a_l[1], data.uSpeeds[t_i - 1][s_i], rlons, rlats, 2) * tf1;\n      var b_v = -idw(a_l[0], a_l[1], data.vSpeeds[t_i - 1][s_i], rlons, rlats, 2) * tf1;\n      var f_u = (a_u + b_u) / 2;              // final u_distance\n      var f_v = (a_v + b_v) / 2;              // final v_distance\n      var f_d = utils.vectorLength(f_u, f_v); // final distance\n      var f_a = Math.atan2(f_u, f_v);         // final angle\n      var f_l = utils.geo.destinationRad(p_0, f_a, f_d);  // final position p_0 + 1/2(a + b)\n      var den = idw(f_l[0], f_l[1], data.densities[t_i - 1][s_i], rlons, rlats, 2);\n      var dat = projection(f_l);  // projection of the location in pixel-space\n      dat.push(den, f_a + Math.PI, f_l, f_d, -f_u, -f_v, t_i - 1);\n      return dat;\n    }\n\n    /**\n     * @param p_0 {array} source position as [longitude, latitude] array\n     * @param t_i {number} source segment index\n     * @param s_i {number} strata index\n     */\n    function stepForward(p_0, t_i, s_i) {\n      var a_u, a_v, a_d, a_a, a_l, f_u, f_v, f_d, f_a, f_l, den, dat;\n      a_u = idw(p_0[0], p_0[1], data.uSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      a_v = idw(p_0[0], p_0[1], data.vSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      a_d = utils.vectorLength(a_u, a_v);  // distance a\n      a_a = Math.atan2(a_u, a_v);          // angle a\n      a_l = utils.geo.destinationRad(p_0, a_a, a_d);  // location p_0 + a\n      if (t_i + 1 >= data.densities.length) {\n        f_u = a_u;\n        f_v = a_v;\n        f_d = a_d;\n        f_a = a_a;\n        f_l = a_l;\n        den = idw(f_l[0], f_l[1], data.densities[t_i][s_i], rlons, rlats, 2);\n      }\n      else {\n        try {\n          var b_u = idw(a_l[0], a_l[1], data.uSpeeds[t_i + 1][s_i], rlons, rlats, 2) * tf1;\n          var b_v = idw(a_l[0], a_l[1], data.vSpeeds[t_i + 1][s_i], rlons, rlats, 2) * tf1;\n        }\n        catch (error) {\n          console.error(\"- a_l:\", a_l);\n          console.error(\"- t_i:\", t_i, \"s_i:\", s_i);\n          console.error(\"- data.uSpeeds:\", data.uSpeeds);\n          console.error(\"- data.uSpeeds[t_i + 1]:\", data.uSpeeds[t_i + 1]);\n          throw error;\n        }\n        f_u = (a_u + b_u) / 2;              // final u_distance\n        f_v = (a_v + b_v) / 2;              // final v_distance\n        f_d = utils.vectorLength(f_u, f_v); // final distance\n        f_a = Math.atan2(f_u, f_v);         // final angle\n        f_l = utils.geo.destinationRad(p_0, f_a, f_d);  // final position p_0 + 1/2(a + b)\n        den = idw(f_l[0], f_l[1], data.densities[t_i + 1][s_i], rlons, rlats, 2);\n      }\n      dat = projection(f_l);  // projection of the location in pixel-space\n      dat.push(den, f_a, f_l, f_d, f_u, f_v, t_i + 1);\n      return dat;\n    }\n\n    var segn = Math.min(data.segmentCount, data.densities.length);\n    var half = Math.floor(data.segmentCount / 2);\n    var segi, loc, d_u, d_v, dat, ang, dis, den;\n    //console.log(\"rlons:\", rlons, \"rlats:\", rlats, \"segn:\", segn);\n\n    // middle point on anchor position:\n    loc = anchorLoc;       // the current location, initially the location of the path's anchor\n    dat = projection(loc);  // projection of the location in pixel-space\n    try {\n      d_u = idw(loc[0], loc[1], data.uSpeeds[half][stri], rlons, rlats, 2) * tf1;  // interpolated u-speed\n    } catch (error) {\n      console.error(\"loc:\", loc);\n      console.error(\"data.uSpeeds:\", data.uSpeeds);\n      console.error(\"half:\", half);\n      console.error(\"data.uSpeeds[half]:\", data.uSpeeds[half]);\n      throw error;\n    }\n    d_v = idw(loc[0], loc[1], data.vSpeeds[half][stri], rlons, rlats, 2) * tf1;  // interpolated v-speed\n    den = idw(loc[0], loc[1], data.densities[half][stri], rlons, rlats, 2);      // interpolated density\n    ang = Math.atan2(d_u, d_v);         // angle\n    dis = utils.vectorLength(d_u, d_v);  // distance\n    dat.push(den, ang, loc, d_u, d_v, dis, \"anchor\");\n    pathData.push(dat);\n\n    //console.log(\"loc:\", loc, \"d_u:\", d_u, \"d_v:\", d_v);\n    //console.log(\"den:\", den, \"ang:\", ang, \"dis:\", dis, \"dat:\", dat);\n    //console.log(\"1:\", pathData);\n\n    // tail half, backwards from middle to first segment\n    for (segi = half; segi > 0; segi--) {\n      try {\n        dat = stepBackward(loc, segi, stri);\n      }\n      catch (error) {\n        console.error(\"- segi: \" + segi + \", segn: \" + segn + \", stri: \" + stri);\n        throw error;\n      }\n      pathData.unshift(dat);\n      loc = dat[pdi_location];\n    }\n\n    // front half, forwards from middle to last segment:\n    loc = anchorLoc;\n    for (segi = half; segi < segn; segi++) {\n      try {\n        dat = stepForward(loc, segi, stri);\n      }\n      catch (error) {\n        console.error(\"- segi: \" + segi + \", segn: \" + segn + \", stri: \" + stri);\n        throw error;\n      }\n      pathData.push(dat);\n      loc = dat[pdi_location];\n    }\n\n    // remove all data points with speed = 0:\n    var len = pathData.length;\n    var i = 0;\n    while (i < len) {\n      if (pathData[i][pdi_distance] == 0) {\n        pathData.splice(i, 1);\n        len--;\n      }\n      else {\n        i++;\n      }\n    }\n\n    // minimize angle delta between subsequent angles:\n    utils.minimizeAngleDelta(pathData.length,\n      function (idx) { return pathData[idx][pdi_angle]; },\n      function (idx, val) { pathData[idx][pdi_angle] = val; }\n    );\n\n    //DEBUG:\n    //if (anchorLoc == app.anchorLocations[DEBUG_ANCHOR_IDX]) {\n    //  var densities = [];\n    //  var angles = [];\n    //  var uSpeeds = [];\n    //  var vSpeeds = [];\n    //  var speeds = [];\n    //  var segs = [];\n    //  pathData.forEach(function (ary) {\n    //    // [x, y, de, a2, l2, u2, v2, segi]\n    //    densities.push(ary[2]);\n    //    angles.push(ary[3]);\n    //    uSpeeds.push(ary[5]);\n    //    vSpeeds.push(ary[6]);\n    //    speeds.push(ary[7]);\n    //    segs.push(ary[8]);\n    //  });\n    //  console.log(\"pathData\", pathData);\n    //  console.log(\"densities\", densities);\n    //  console.log(\"angles\", angles);\n    //  console.log(\"uSpeeds\", uSpeeds);\n    //  console.log(\"vSpeeds\", vSpeeds);\n    //  console.log(\"speeds\", speeds);\n    //  console.log(\"segs\", segs);\n    //}\n\n    return pathData;\n  };\n\n  /**\n   * @private\n   * Generates the outline of a path with a variable width that reflects the\n   * density variability.\n   *\n   * @param pathData {array} A data structure as returned by paths.buildPathData.\n   * @returns {Array} [[<x>, <y>], ...]\n   */\n  paths.buildOutline = function (pathData) {\n    var lineData = [];\n    if (pathData.length == 0) { return lineData; }\n\n    var segn = pathData.length - 1;\n    var segi, segd, angle, radius, dx, dy;\n    var minRadius = .25;\n\n    segd = pathData[0];\n    if (segd == undefined) {\n      console.error(pathData);\n      throw new Error();\n    }\n    radius = minRadius + segd[pdi_density] * radiusFactor;\n    angle = segd[pdi_angle] + Math.PI * .5;\n    dx = Math.sin(angle) * radius;\n    dy = -Math.cos(angle) * radius;\n    lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n    lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n\n    for (segi = 1; segi < segn; segi++) {\n      segd = pathData[segi];\n      angle = (pathData[segi - 1][pdi_angle] + segd[pdi_angle] + Math.PI) * .5;\n      radius = minRadius + segd[pdi_density] * radiusFactor;\n      dx = Math.sin(angle) * radius;\n      dy = -Math.cos(angle) * radius;\n      lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n      lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n    }\n\n    segd = pathData[segn];\n    radius = minRadius + segd[pdi_density] * radiusFactor;\n    angle = segd[pdi_angle] + Math.PI * .5;\n    dx = Math.sin(angle) * radius;\n    dy = -Math.cos(angle) * radius;\n    lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n    lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n\n    return lineData;\n  };\n\n  /**\n   * @private\n   * Draws a path with variable thickness.\n   *\n   * @param flowG {object} The svg group element in which to draw the path.\n   * @param pathData {array} A data structure as returned by paths.buildPathData.\n   * @param lineData {array} A data structure as returned by paths.buildOutline.\n   * @param pathColor {string} Hex-string that represents a color.\n   */\n  paths.drawPath = function (flowG, pathData, lineData, pathColor) {\n    //console.log(lineData.map(function (d) {\n    //  return '[' + d[0] + ', ' + d[1] + ']';\n    //}));\n\n    var segn = pathData.length - 1;\n    var radius;\n\n    // draw paths:\n    var opacity = config.arty ? .6 : .7;\n    flowG.append(\"path\")\n      .attr(\"d\", paths._lineFn(lineData))\n      .style({fill: pathColor, \"fill-opacity\": opacity });\n\n    // draw head dot:\n    if (config.arty) {\n      radius = 0;\n      pathData.forEach(function (d) { radius += d[2]; });\n      radius = Math.max(1, radius / pathData.length);\n      opacity = .5;\n    }\n    else {\n      radius = utils.constrain(pathData[segn][2] * radiusFactor + .5, 1.5, 3);\n      opacity = 1;\n    }\n    flowG.append('circle')\n      .attr('cx', pathData[segn][0])\n      .attr('cy', pathData[segn][1])\n      .attr('r', radius)\n      .attr(\"style\", \"fill: \" + pathColor + \"; fill-opacity: \" + opacity + \";\");\n  };\n\n  /**\n   * @private\n   * D3 line function used in paths.drawPath.\n   */\n  paths._lineFn = d3.svg.line()\n    .x(function (d) { return d[0]; })\n    .y(function (d) { return d[1]; })\n    .interpolate(\"cardinal-closed\");\n\n  return paths;\n}\n","\"use strict\";\n\nfunction viz_(_config, _utils) {\n\n  // dependencies:\n  var config = _config;\n  var utils = _utils;\n  var paths = viz_paths_(_config, _utils);\n  var legends = viz_legends_(_config, _utils);\n\n  // service object:\n  var viz = {};\n\n  // private properties:\n  var svg;\n  var pathsG;\n  var clipG;\n  var mapW = 0;         // the width of the map\n  var mapH = 0;         // the height of the map\n  var projection;       // the d3.geo projection used to map locations to pixels\n  var projectionPath;   // the d3.geo.path object with which to draw the geography\n  var anchorLocations;\n\n  /**\n   * Updates all the base map related data, such as it's size, the size of the\n   * legends, the geographic projection, etc.\n   *\n   * @param caseStudy {object} The models.caseStudy object.\n   */\n  viz.updateMapData = function (caseStudy) {\n    //console.log(\">> viz.updateMapData()\");\n    var svgRect = d3.select(\"#map-container\").node().getBoundingClientRect();\n    mapW = svgRect.width;\n    mapH = mapW * config.mapHeightFactor;\n\n    // specify the projection based of the size of the map:\n    projection = caseStudy.getProjection(caseStudy, mapW, mapH);\n\n    // initialize the d3 path with which to draw the geography:\n    projectionPath = d3.geo.path().projection(projection);\n\n    // Update pixels properties of radar objects. These properties are objects\n    // with an x and a y property, the position of the radar in pixel-space.\n    caseStudy.radars.forEach(function (radar) {\n      var projected = projection(radar.location);\n      radar.pixels = { x: projected[0], y: projected[1] }\n    });\n\n    // Update the anchors:\n    this.initAnchors(caseStudy);\n  };\n\n  /** @private Initialize the anchors. */\n  viz.initAnchors = function (caseStudy) {\n    //console.log(\">> viz.initAnchors()\");\n    var locTopLeft = projection.invert([0, 0]);  // the location at the top-left corner\n    var locBotRight = projection.invert([mapW, mapH]);  // the loc. at the bottom-right\n    var rra = utils.geo.distAngle(config.radarAnchorRadius);  // radar radius as angle\n    var dlon = utils.geo.destination(caseStudy.mapCenter, 90, caseStudy.anchorInterval)[0]\n      - caseStudy.mapCenter[0];  // longitude delta\n    var dlat = utils.geo.destination(caseStudy.mapCenter, 0, caseStudy.anchorInterval)[1]\n      - caseStudy.mapCenter[1];  // latitude delta\n    anchorLocations = [];\n    for (var lon = locTopLeft[0]; lon < locBotRight[0]; lon += dlon) {\n      for (var lat = locTopLeft[1]; lat > locBotRight[1]; lat -= dlat) {\n        caseStudy.radars.forEach(function (radar) {\n          if (utils.degrees(d3.geo.distance(radar.location, [lon, lat])) <= rra) {\n            anchorLocations.push([lon, lat]);\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * Redraws the base map (not the paths).\n   *\n   * @param caseStudy {object} The models.caseStudy object.\n   */\n  viz.redrawMap = function (caseStudy) {\n    // create/replace svg object:\n    if (svg) { svg.remove(); }\n    svg = d3.select(\"#map-container\").append(\"svg\")\n      .attr(\"width\", mapW)\n      .attr(\"height\", mapH)\n      .classed(\"visualisation\", true);\n\n    // add clip-path:\n    svg.append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"clipRect\")\n      .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", mapW)\n      .attr(\"height\", mapH);\n\n    clipG = svg.append(\"g\");\n    clipG.attr(\"style\", \"clip-path: url(#clipRect);\");\n    if (config.arty) {\n      clipG.attr(\"style\", \"background: #fff;\");\n    }\n    else {\n      var mapG = clipG.append(\"g\").attr(\"id\", \"map\");\n      this.drawMap(mapG, caseStudy);\n    }\n    pathsG = clipG.append(\"g\").attr(\"id\", \"paths\");\n\n  };\n\n  /* @private Map draw helper */\n  viz.drawMap = function (mapG, caseStudy) {\n    mapG.append(\"rect\")\n      .attr(\"id\", \"background\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", mapW)\n      .attr(\"height\", mapH);\n    mapG.append(\"path\")\n      .attr(\"id\", \"land\")\n      .datum(topojson.feature(\n        caseStudy.topoJson,\n        caseStudy.topoJson.objects.countries\n      ))\n      .attr(\"d\", projectionPath);\n    mapG.append(\"path\")\n      .attr(\"id\", \"country-boundary\")\n      .datum(topojson.mesh(\n        caseStudy.topoJson,\n        caseStudy.topoJson.objects.countries,\n        function(a, b) { return a !== b; }\n      ))\n      .attr(\"d\", projectionPath);\n    mapG.append(\"path\")\n      .attr(\"id\", \"graticule\")\n      .datum(d3.geo.graticule().step([1, 1]))\n      .attr(\"d\", projectionPath);\n\n    // draw radars:\n    var rra = utils.geo.distAngle(config.radarAnchorRadius); // radar radius as angle:\n    var radarG = mapG.append(\"g\").attr(\"id\", \"radars\");\n    caseStudy.radars.forEach(function (radar) {\n      radarG.append(\"path\")\n        .attr(\"id\", \"radar-radius\")\n        .datum(d3.geo.circle().origin(radar.location).angle(rra))\n        .attr(\"d\", projectionPath);\n\n      // Draw series points around radar at the marker radius:\n      //var n = 36;\n      //for (var i = 0; i < n; i++) {\n      //  var bearing = utils.mapRange(i, 0, n, 0, 360);\n      //  var dest = utils.geo.destination(radar.location, bearing, config.radarAnchorRadius);\n      //  radarG.append(\"path\")\n      //    .datum(d3.geo.circle().origin(dest).angle(.01))\n      //    .attr(\"d\", projectionPath)\n      //    .classed(\"highlight3\", true);\n      //}\n    });\n\n    // optionally draw radar labels:\n    if (config.showRadarLabels) {\n      var radarLabelsG = mapG.append(\"g\").attr(\"id\", \"radar-labels\");\n      caseStudy.radars.forEach(function (radar) {\n        radarLabelsG.append('circle')\n          .attr('cx', radar.pixels.x)\n          .attr('cy', radar.pixels.y)\n          .attr('r', 1.5)\n          .classed(\"radar-center\", true);\n        radarLabelsG\n          .append(\"text\")\n          .attr(\"x\", radar.pixels.x + 4)\n          .attr(\"y\", radar.pixels.y + 10)\n          .text(radar.id)\n          .classed(\"radar-label\", true);\n      });\n    }\n  };\n\n  /**\n   * Draw the paths.\n   *\n   * @param data\n   */\n  viz.drawPaths = function (data) {\n    paths.drawPaths(data, anchorLocations, projection, pathsG);\n  };\n\n  /**\n   * draw the legends\n   */\n  viz.drawLegends = function (caseStudy, focus) {\n    if (!config.arty) {\n      var legendG = clipG.append(\"g\").attr(\"id\", \"color-legend\");\n      legends.drawColorLegend(legendG, caseStudy, focus);\n\n      legendG = clipG.append(\"g\").attr(\"id\", \"scale-legend\");\n      legends.drawScaleLegend(legendG, mapW, mapH, projection, caseStudy);\n\n      if (config.writeMetaDataInViz) {\n        var mdG = clipG.append(\"g\").attr(\"id\", \"meta-data\");\n        legends.writeMetaData(mdG, mapH, focus);\n      }\n    }\n  };\n\n  return viz;\n}\n","/**\n * eu15a case-study.\n */\nfunction eu15a(models) {\n  return models.caseStudy(\"eu15a\", jsonDataService(models));\n}\n","/**\n * us15a case-study.\n */\nfunction us15a(models) {\n  return models.caseStudy(\"us15a\", jsonDataService(models));\n}\n"],"sourceRoot":"/source/"}