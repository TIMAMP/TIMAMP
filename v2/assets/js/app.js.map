{"version":3,"sources":["utils.js","data.js","enram.js","app.js","case-study.js","timamp.js","eu15a/init.js","us15a/init.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["\nvar utils = (function () {\n\n  \"use strict\";\n\n  var utils = {};\n\n  /**\n   * Identity function, simply returns the first argument.\n   * @param {*} d\n   * @returns {*}\n   */\n  utils.id = function (d) { return d; }\n\n  // #############################################################################\n  // Geometric functions\n  // -----------------------------------------------------------------------------\n\n  utils.geo = {};\n\n  /** @const */\n  utils.geo._GEO_DIST_FACTOR = 360 / (6371 * 2 * Math.PI);\n\n  /**\n   * Returns the angle (in degrees) corresponding with the given displacement in km.\n   * The angle (in degrees) of a displacement of 1 km horizontally along the equator:\n   * 1 km = 1 / (2 * 6371 * pi) * 360 degrees = 0.008993216059 degrees.\n   * Inversely: 1 degree ~= 111.19492664 km\n   *\n   * @param {Number} dist The distance in km.\n   * @returns {number}\n   */\n  utils.geo.distAngle = function (dist) {\n    return dist * utils.geo._GEO_DIST_FACTOR;\n  };\n\n  /**\n   * Returns the destination location, given a start location, a bearing and a\n   * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n   * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n   * @param  {number}        bearing in degrees clockwise from north\n   * @param  {number}        distance in km\n   * @return {Array<number>} a [lon, lat] coordinate in degrees\n   */\n  utils.geo.destination = function (start, bearing, distance) {\n    var dR = distance / 6371;  // angular distance = distance / earth’s radius\n    var lat1 = utils.radians(start[1]);\n    var lon1 = utils.radians(start[0]);\n    bearing = utils.radians(bearing);\n    var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n      Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n    var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n        Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n    //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n    return [utils.degrees(lon2), utils.degrees(lat2)];\n  };\n\n  /**\n   * Returns the destination location, given a start location, a bearing and a\n   * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n   * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n   * @param  {number}        bearing in radians clockwise from north\n   * @param  {number}        distance in km\n   * @return {Array<number>} a [lon, lat] coordinate in degrees\n   */\n  utils.geo.destinationRad = function (start, bearing, distance) {\n    var dR = distance / 6371;  // angular distance = distance / earth’s radius\n    var lat1 = utils.radians(start[1]);\n    var lon1 = utils.radians(start[0]);\n    var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n      Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n    var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n        Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n    //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n    return [utils.degrees(lon2), utils.degrees(lat2)];\n  };\n\n  // #############################################################################\n  // Interpolation\n  // -----------------------------------------------------------------------------\n\n  utils.idw = function (x, y, tValues, xValues, yValues, power) {\n    if (tValues === undefined || tValues === null) {\n      throw new Error(\"tValues is undefined in utils.idw()\");\n    }\n    if (xValues === undefined || xValues === null) {\n      throw new Error(\"xValues is undefined in utils.idw()\");\n    }\n    if (yValues === undefined || yValues === null) {\n      throw new Error(\"yValues is undefined in utils.idw()\");\n    }\n    if (tValues.length != xValues.length) {\n      throw \"tValues.length != xValues.length\";\n    }\n    if (xValues.length != yValues.length) {\n      throw \"xValues.length != yValues.length\";\n    }\n    var len = tValues.length, i, dx, dy, wi, ws = 0, r = 0;\n    for (i = 0; i < len; i++) {\n      dx = x - xValues[i];\n      dy = y - yValues[i];\n      if (dx == 0 && dy == 0) { return tValues[i]; }\n      wi = 1 / Math.pow(Math.sqrt(dx * dx + dy * dy), power);\n      r += wi * tValues[i];\n      ws += wi;\n    }\n    return r / ws;\n  };\n\n  // #############################################################################\n  // Color functions\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Transforms HSB to RGB color. Accepts either 3 arguments (hue, saturaion and\n   * value/brightness in  the range [0, 1]), or 1 argument (an object with h, s\n   * and v properties in the range [0, 1]).\n   * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * @param   {Number|Object} h The hue value in the range [0, 1], or an\n   *                            object with three properties {h:h, s:s, v:v}.\n   * @param   {Number}        s The saturation in the range [0, 1].\n   * @param   {Number}        v The value/brightness in the range [0, 1].\n   * @returns {Object}        An object with r, g and b properties in the range\n   *                          [0, 255].\n   */\n  utils.hsvToRgb = function (h, s, v) {\n    var r, g, b, i, f, p, q, t;\n    if (h && s === undefined && v === undefined) {\n      s = h.s, v = h.v, h = h.h;\n    }\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n    }\n    return {\n      r: Math.floor(r * 255),\n      g: Math.floor(g * 255),\n      b: Math.floor(b * 255)\n    };\n  };\n\n  /**\n   * Converts an RGB color value to HSL.\n   * Assumes r, g, and b are contained in the set [0, 255] and\n   * returns h, s, and l in the set [0, 1].\n   * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * @param   {Number|Object} r The red color value in the range [0, 255], or an\n   *                            object with three properties {r:r, g:g, b:b}.\n   * @param   {Number}        g The green color value in the range [0, 255].\n   * @param   {Number}        b The blue color value in the range [0, 255].\n   * @returns {Array}         An object with h, a and v properties in the range\n   *                          [0, 1].\n   */\n  utils.rgbToHsv = function (r, g, b) {\n    var min, max, h, s, v, d;\n    if (r && g === undefined && b === undefined) {\n      g = r.g, b = r.b, r = r.r;\n    }\n    r = r / 255, g = g / 255, b = b / 255;\n    max = Math.max(r, g, b), min = Math.min(r, g, b);\n    v = max;\n    d = max - min;\n    s = max === 0 ? 0 : d / max;\n    if (max == min) {\n      h = 0; // achromatic\n    } else {\n      switch (max) {\n        case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n        case g: h = (b - r) / d + 2; break;\n        case b: h = (r - g) / d + 4; break;\n      }\n      h /= 6;\n    }\n    return {h:h, s:s, v:v};\n  };\n\n  /**\n   * Transform the given r, g and b values in the range [0, 255] to its\n   * hex-representation.\n   * @param   {Number|Object} r The red color value in the range [0, 255], or an\n   *                            object with three properties {r:r, g:g, b:b}.\n   * @param   {Number}        g The green color value in the range [0, 255].\n   * @param   {Number}        b The blue color value in the range [0, 255].\n   * @returns {String}        The hex represenation of the rgb value.\n   */\n  utils.rgbToHex = function (r, g, b) {\n    if (r && g === undefined && b === undefined) {\n      g = r.g, b = r.b, r = r.r;\n    }\n    r = r.toString(16);\n    if (r.length == 1) r = \"0\" + r;\n    g = g.toString(16);\n    if (g.length == 1) g = \"0\" + g;\n    b = b.toString(16);\n    if (b.length == 1) b = \"0\" + b;\n    return \"#\" + r + g + b;\n  };\n\n  utils.hsvToHex = function (h, s, v) {\n    return utils.rgbToHex(utils.hsvToRgb(h, s, v));\n  };\n\n  utils.hsvaToRgba = function (h, s, v, a) {\n    var rgb = utils.hsvToRgb(h, s, v);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + a + \")\";\n  };\n\n  // #############################################################################\n  // Statistics\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Returns the average of the values in the given array.\n   * @param   {Array}            ary     An array with numbers.\n   * @param   {*}                undefAv The return value when the array is empty.\n   * @returns {Number|undefined} The average or undefined if the array is empty.\n   */\n  utils.average = function (ary, undefAv) {\n    if (arguments.length === 1) { undefAv = 0; }\n    if (ary === undefined) { return undefAv; }\n    var len = ary.length;\n    if (len === 0) { return undefAv;  }\n    var r = 0;\n    for (var i = 0; i < len; i++) { r += ary[i]; }\n    return r / len;\n  };\n\n  /**\n   * Returns the average of a list of displacements, given as an array of\n   * directions and an array of corresponding speeds. These array should have\n   * the same length.\n   * @param   {Array}            angles List of angles in radias.\n   * @param   {Array}            speeds List of speeds.\n   * @param   {*}                undefAv The return value when the array is empty.\n   * @returns {Object|undefined} An object with angle and speed properties or\n   *                             undefined if the given arrays are empty.\n   */\n  utils.averageDisplacement = function (angles, speeds, undefAv) {\n    if (angles === undefined || speeds === undefined) { return undefAv; }\n    var len = angles.length;\n    if (len === 0) { return undefAv; }\n    var x = 0, y = 0;\n    for (var i = 0; i < len; i++) {\n      x += Math.cos(angles[i]) * speeds[i];\n      y += Math.sin(angles[i]) * speeds[i];\n    }\n    x /= len;\n    y /= len;\n    return {\n      angle: Math.atan2(x, y),\n      speed: Math.sqrt(x * x + y * y)\n    };\n  };\n\n  // #############################################################################\n  // Math utilities\n  // -----------------------------------------------------------------------------\n\n  utils.TWO_PI = Math.PI * 2;\n\n  /**\n   * Returns the given angle in degrees expressed as radians.\n   * @param   {Number} degrees The given angle in degrees.\n   * @returns {Number} The given angle in radians.\n   */\n  utils.radians = function (degrees) {\n    return degrees * Math.PI / 180;\n  };\n\n  /**\n   * Normalize the given angle in radians.\n   * @param angle\n   * @returns the normalized angle, i.e. 0 <= angle < Pi * 2\n   */\n  utils.normRadians = function (angle) {\n    while (angle < 0) {\n      angle += utils.TWO_PI;\n    }\n    while (angle >= utils.TWO_PI) {\n      angle -= utils.TWO_PI;\n    }\n    return angle;\n  };\n\n  utils.minimizeAngleDelta = function (count, getter, setter) {\n    if (count == 0) { return; }\n    var ac = getter(0);\n    for (var i = 1; i < count; i++) {\n      var ai = getter(i);\n      while (ai > ac + Math.PI) { ai -= utils.TWO_PI; }\n      while (ai < ac - Math.PI) { ai += utils.TWO_PI; }\n      setter(i, ai);\n      ac = ai;\n    }\n  };\n\n  /**\n   * Returns the given angle in radians expressed as degrees.\n   * @param   {Number} radians The given angle in radians.\n   * @returns {Number} The given angle in degrees.\n   */\n  utils.degrees = function (radians) {\n    return radians / Math.PI * 180;\n  };\n\n  /**\n   * Maps the value v from the source range [a, b] to the target range [c, d].\n   * @param   {Number} value The value to map.\n   * @param   {Number} low1 The first bound of the source range.\n   * @param   {Number} high1 The second bound of the source range.\n   * @param   {Number} low2 The first bound of the target range.\n   * @param   {Number} high2 The second bound of the target range.\n   * @returns {Number} The mapped value.\n   */\n  utils.mapRange = function (value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n  };\n\n  /**\n   * Constrains the given value v to the range [min, max]\n   * @param   {Number} v   The value to constrain.\n   * @param   {Number} min The minimum value of the range.\n   * @param   {Number} max The maximum value of the range.\n   * @returns {Number} The constrained value.\n   */\n  utils.constrain = function (v, min, max) {\n    if (v < min) return min;\n    else if (v > max) return max;\n    else return v;\n  };\n\n  /**\n   * Calculates the length of the vector (dx, dy).\n   * @param   {Number} dx [[Description]]\n   * @param   {Number} dy [[Description]]\n   * @returns {Number} [[Description]]\n   */\n  utils.vectorLength = function (dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  // #############################################################################\n  // Support functions\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Return the size of one em in pixels.\n   * @returns {Number} The size of one em in pixels.\n   */\n  utils.emSize = function () {\n    return parseFloat($(\"body\").css(\"font-size\"));\n  };\n\n  /**\n   * Creates a list with n zeros.\n   * @param   {Number}   length The number of zeros to\n   * @returns {[[Type]]} [[Description]]\n   */\n  utils.zeroArray = function (length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n      result.push(0);\n    }\n    return result;\n  };\n\n  // -----------------------------------------------------------------------------\n\n  utils.debug = function (name, value) {\n    //$(\"#debug\").append(\"<p>\" + name + \": \" + value + \"</p>\");\n    if (name && value === undefined) {\n      console.log(name);\n    }\n    else {\n      console.log(name + \": \" + value);\n    }\n  };\n\n  // -----------------------------------------------------------------------------\n\n  /** Polyfill String.trim for old browsers\n   *  (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */\n  if (String.prototype.trim === undefined) {\n    String.prototype.trim = function() {\n      return String(this).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    };\n  }\n\n  // -----------------------------------------------------------------------------\n\n  /**\n   * Simple string formatting borrowed from\n   * http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format/4673436#4673436\n   * For a more advance formatter, see https://github.com/alexei/sprintf.js.\n   *\n   * Usage: \"{0} is dead, but {1} is alive! {0} {2}\".format(\"ASP\", \"ASP.NET\")\n   * >> ASP is dead, but ASP.NET is alive! ASP {2}\n   */\n  if (!String.prototype.format) {\n    String.prototype.format = function() {\n      var args = arguments;\n      return this.replace(/{(\\d+)}/g, function(match, number) {\n        return typeof args[number] != 'undefined' ? args[number] : match;\n      });\n    };\n  }\n\n  return utils;\n\n})();","/*jshint undef: false, unused: true, laxbreak: true*/\n/*jslint vars: true, plusplus: true*/\n/*global define*/\n\n\"use strict\";\n\n// -----------------------------------------------------------------------------\n// Json-based DataService\n// -----------------------------------------------------------------------------\n\nfunction JsonDataService() {\n  var dataService = {};\n  var checkData = true;\n  var sourceData = null;\n  var currFocus = null;\n\n  /**\n   * Initializes the dataService.\n   * @param caseStudy {enram.caseStudy}\n   * @param handler {function}\n   */\n  dataService.initialize = function(caseStudy, handler) {\n    handler();\n  };\n\n  /**\n   * Loads the data for the given focus.\n   * @param caseStudy {enram.caseStudy}\n   * @param focus     {enram.focus}\n   * @param handler   {function(dataObject)} called when the data is loaded\n   */\n  dataService.loadFocusData = function (caseStudy, focus, handler) {\n    //console.log(\">> dataService.loadFocusData()\");\n    if (currFocus == undefined || currFocus.strataOptionIdx != focus.strataOptionIdx) {\n      // update source data:\n      var dataPath = caseStudy.urlBase + \"data-\" + focus.strataOptionIdx + \".json\";\n      d3.json(dataPath, function (error, json) {\n        if (error) {\n          console.error(error);\n          //throw new Error(\"Error in dataService.loadCaseStudy. \"\n          //    + JSON.parse(error.responseText).error.join(\"; \"));\n          return;\n        }\n\n        sourceData = json;\n        currFocus = focus;\n        dataService._loadFocusData_next(caseStudy, focus, handler);\n      });\n    }\n    else {\n      this._loadFocusData_next(caseStudy, focus, handler);\n    }\n  };\n\n  dataService._loadFocusData_next = function (caseStudy, focus, handler) {\n    var data = timamp.dataObject(caseStudy, focus);\n    var dt = focus.from.valueOf() - caseStudy.dataFrom.valueOf();\n    var segmentSec = caseStudy.segmentSize * 60 * 1000;\n    var iFrom = Math.floor(dt / segmentSec);\n    // add one in the following to allow for the 2-stage Runge–Kutta interpolation\n    var iTill = iFrom + data.segmentCount + 1;\n    var iMax = sourceData.densities.length;\n    //console.log(iFrom, caseStudy.dataFrom.toDate(), focus.from.toDate());\n\n    // Warn when the focus interval does not intersect the available interval:\n    if (iFrom >= iMax) {\n      console.error(\"The focus starts after the available data interval.\");\n      data.appendMissingSegments(data.segmentCount + 1);\n      handler(data);\n      return;\n    }\n    if (iTill < 0) {\n      console.error(\"The focus end before the available data interval.\");\n      data.appendMissingSegments(data.segmentCount + 1);\n      handler(data);\n      return;\n    }\n\n    // Remember to prepend or append missing data entries:\n    var prepend = 0;\n    var append = 0;\n    if (iFrom < 0) {\n      prepend = - iFrom;\n      iFrom = 0;\n    }\n    if (iTill > iMax) {\n      append = iTill - iMax;\n      iTill = iMax;\n    }\n    //console.log(iFrom, iTill, iMax, prepend, append);\n\n    // Use slices of the source data as focus data:\n    data.densities = sourceData.densities.slice(iFrom, iTill);\n    data.uSpeeds = sourceData.uSpeeds.slice(iFrom, iTill);\n    data.vSpeeds = sourceData.vSpeeds.slice(iFrom, iTill);\n    data.speeds = sourceData.speeds.slice(iFrom, iTill);\n\n    // Calculate average densities per radar-altitude combination, integrated\n    // over the strata height. These numbers thus represent the number of birds\n    // per square km in a given strata. The average density is calculated over\n    // the segments for which a (partial) path is shown, i.e. for which speed\n    // and density > 0.\n    var strn = data.strataCount;\n    var radn = caseStudy.radarCount;\n    var segn = data.densities.length;\n    var stri, radi, segi;\n    for (stri = 0; stri < strn; stri++) {\n      var avds = [];\n      var strataSize = data.strataSize(stri);\n      for (radi = 0; radi < radn; radi++) {\n        var cnt = 0;\n        var sum = 0;\n        for (segi = 0; segi < segn; segi++) {\n          var den = data.densities[segi][stri][radi];\n          if (den > 0 && data.speeds[segi][stri][radi] > 0) {\n            cnt++;\n            sum += den\n          }\n        }\n        if (cnt == 0) {\n          avds.push(0);\n        } else {\n          if (sum == 0) {\n            console.error(\"avDensity is zero for stri \" + stri + \" and radi \" + radi);\n          }\n          avds.push(sum / cnt * strataSize);\n        }\n      }\n      data.avDensities.push(avds);\n    }\n\n    // Prepend or append missing data:\n    if (prepend > 0) { data.prependMissingSegments(prepend); }\n    if (append > 0) { data.appendMissingSegments(append); }\n\n    if (data.densities.length != data.segmentCount + 1) {\n      throw new Error(\"The data object does not have the proper amount of \" +\n        \"entries. [data.densities.length: \" + data.densities.length +\n        \", data.segmentCount + 1: \" + (data.segmentCount + 1) + \"]\");\n    }\n\n    if (checkData) {\n      this._checkData(data);\n    }\n\n    handler(data);\n  };\n\n  /** Check if the given data is OK:\n   * - densities: data matrix with dimensions: [segments, strata, radars].\n   * - uSpeeds: data matrix with dimensions: [segments, strata, radars].\n   * - vSpeeds: data matrix with dimensions: [segments, strata, radars].\n   * - speeds: data matrix with dimensions: [segments, strata, radars].\n   * - avDensities: data matrix with dimensions: [strata, radars].\n   */\n  dataService._checkData = function (data) {\n    var segn = data.segmentCount + 1; // add one to allow two-phase integration\n    var strn = data.strataCount;\n    var radn = data.caseStudy.radarCount;\n    var segi, stri;\n\n    if (data.densities.length != segn) {\n      throw (\"data.densities.length (\" + data.densities.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.uSpeeds.length != segn) {\n      throw (\"data.uSpeeds.length (\" + data.uSpeeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.vSpeeds.length != segn) {\n      throw (\"data.vSpeeds.length (\" + data.vSpeeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n    if (data.speeds.length != segn) {\n      throw (\"data.speeds.length (\" + data.speeds.length +\n        \") != segn (\" + segn + \")\");\n    }\n\n    for (segi = 0; segi < segn; segi++) {\n      if (data.densities[segi].length != strn) {\n        throw (\"data.densities[segi].length (\" + data.densities[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.uSpeeds[segi].length != strn) {\n        throw (\"data.uSpeeds[segi].length (\" + data.uSpeeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.vSpeeds[segi].length != strn) {\n        throw (\"data.vSpeeds[segi].length (\" + data.vSpeeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n      if (data.speeds[segi].length != strn) {\n        throw (\"data.speeds[segi].length (\" + data.speeds[segi].length +\n          \") != strn (\" + strn + \")\");\n      }\n\n      for (stri = 0; stri < strn; stri++) {\n        if (data.densities[segi][stri].length != radn) {\n          throw (\"data.densities[segi][stri].length (\" +\n            data.densities[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.uSpeeds[segi][stri].length != radn) {\n          throw (\"data.uSpeeds[segi][stri].length (\" +\n            data.uSpeeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.vSpeeds[segi][stri].length != radn) {\n          throw (\"data.vSpeeds[segi][stri].length (\" +\n            data.vSpeeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n        if (data.speeds[segi][stri].length != radn) {\n          throw (\"data.speeds[segi][stri].length (\" +\n            data.speeds[segi][stri].length + \") != radn (\" + radn + \")\");\n        }\n      }\n    }\n\n    if (data.avDensities.length != strn) {\n      throw (\"data.avDensities.length (\" + data.avDensities.length +\n        \") != strn (\" + strn + \")\");\n    }\n    for (stri = 0; stri < strn; stri++) {\n      if (data.avDensities[stri].length != radn) {\n        throw (\"data.avDensities[stri].length (\" +\n          data.avDensities[stri].length + \") != radn (\" + radn + \")\");\n      }\n    }\n  };\n\n  return dataService;\n} // end dataService\n","/**\n * Created by wouter on 15/12/2015.\n */\n\nvar enram = (function () {\n  //console.log(\">> enram service constructor \", enram);\n\n  var enram = {};\n\n  /**\n   * Creates and returns a focus object.\n   * @param from      {moment}  the start of the focus window\n   * @param duration  {number}  the focus duration in hours\n   * @param strataOptionIdx {number}\n   * @param migrantsPerPath {number}\n   */\n  enram.focus = function (from, duration, strataOptionIdx, migrantsPerPath) {\n    var focus = {\n      from: from,\n      till: moment(from).add(duration, 'hours'),\n      duration: duration,\n      strataOptionIdx: strataOptionIdx,\n      migrantsPerPath: migrantsPerPath,\n      isFocus: true\n    };\n\n    /**\n     * @return the number of segments for the focus and the given case study\n     */\n    focus.segmentCount = function (caseStudy) {\n      return this.duration * 60 / caseStudy.segmentSize;\n    };\n\n    /**\n     * @return the strata option for the focus and the given case study\n     */\n    focus.strataOption = function (caseStudy) {\n      return caseStudy.strataOptions[this.strataOptionIdx];\n    };\n\n    /**\n     * @return the number of strata for the focus and the given case study\n     */\n    focus.strataCount = function (caseStudy) {\n      return this.strataOption(caseStudy).length;\n    };\n\n    /**\n     * Returns a list with the lowest and the highest altitude.\n     * @param caseStudy\n     */\n    focus.altitudeRange = function (caseStudy) {\n      var strataOption = this.strataOption(caseStudy);\n      return [strataOption[0][0], strataOption[strataOption.length - 1][1]];\n    };\n\n    /**\n     * Constrains the focus period to fall within the available data period.\n     * @param caseStudy {enram.caseStudy}\n     * @returns this\n     */\n    focus.constrain = function (caseStudy) {\n      if (this.from.isBefore(caseStudy.dataFrom)) {\n        this.setFrom(moment(caseStudy.dataFrom));\n      }\n      else if (this.till.isAfter(caseStudy.dataTill)) {\n        this.setTill(moment(caseStudy.dataTill));\n      }\n      return this;\n    };\n\n    /**\n     * Update the from moment and the matching till moment.\n     * @param from {moment}\n     */\n    focus.setFrom = function (from) {\n      if (this.from.isSame(from)) return;\n      this.from = from;\n      this.till = moment(from).add(this.duration, 'hours');\n    };\n\n    /**\n     * Update the till moment and the matching from moment.\n     * @param till {moment}\n     */\n    focus.setTill = function (till) {\n      if (this.till.isSame(till)) return;\n      this.till = till;\n      this.from = moment(till).subtract(this.duration, 'hours');\n    };\n\n    /**\n     * Update the duration and the derived till moment.\n     * @param duration {number} the new focus duration in hours\n     */\n    focus.setDuration = function (duration) {\n      if (this.duration == duration) return;\n      this.duration = duration;\n      this.till = moment(from).add(this.duration, 'hours');\n    };\n\n    /**\n     * @returns a clone of the focus object\n     */\n    focus.clone = function () {\n      var clone = {};\n      for (var attr in focus) {\n        if (focus.hasOwnProperty(attr)) { clone[attr] = focus[attr]; }\n      }\n      return clone;\n    };\n\n    return focus;\n  };\n\n  return enram;\n\n})();","/*jshint unused: false, latedef: false */\n/*jslint vars: true, plusplus: true, undef: true, continue: true */\n/*global requirejs, require */\n\n\"use strict\";\n\n// -----------------------------------------------------------------------------\n// Configuration settings that do not change:\n\n/**\n * The radius around radars in km in which path anchors are considered.\n * @type {number}\n */\nvar radarAnchorRadius = 75;\n\n/**\n * The migrants-per-path options.\n */\nvar migrantsPerPathOptions = [\n  { value: 10000, text: \"10K\" },\n  { value: 25000, text: \"25K\" },\n  { value: 50000, text: \"50K\" },\n  { value: 100000, text: \"100K\" },\n  { value: 250000, text: \"250K\" },\n  { value: 500000, text: \"500K\" }\n];\n\n/**\n * The height of the template map divided by its width, used to obtain the actual\n * height of the map, given the actual width after resizing.\n * @type {number}\n */\nvar mapHeightFactor = 940 / 720;\n\n/**\n * The template legend width divided by the template map width, used to obtain the\n * actual width of the legend, given the actual width after resizing.\n * @type {number}\n */\nvar legendWidthFactor = 200 / 720;\n\n/**\n * The minimum value of the range of hues to pick from for strata colors.\n * @type {number}\n */\nvar altiHueMin = 0.5;\n\n/**\n * The maximum value of the range of hues to pick from for strata colors.\n * @type {number}\n */\nvar altiHueMax = 1;\n\n/**\n * The saturation for strata colors.\n * @type {number}\n */\nvar altiSaturation = 1;\n\n/**\n * The brightness for strata colors.\n * @type {number}\n */\nvar altiBrightness = 0.7;\n\n/**\n * The initial focus duration, in hours.\n * @type {number}\n */\nvar defaultFocusDuration = 6;\n\n/**\n * When true then only one path per radar is drawn.\n * @type {boolean}\n */\nvar singlePath = false;\n\n/**\n * When true then basic metadata is provided in the visualisation.\n * @type {boolean}\n */\nvar writeMetaDataInViz = true;\n\n/**\n * When true the special 'arty' mode is activated.\n * @type {boolean}\n */\nvar arty = false;\n\nvar showRadarLabels = true;\n\n// -----------------------------------------------------------------------------\n// System variables:\n\n/** @type {number} */ var mapW = 0;\n/** @type {number} */ var mapH = 0;\n/** @type {number} */ var legendW = 0;\n/** @type {number} */ var anchorArea;\n/** @type {array}  */ var anchorLocations;\n/** @type {Object} */ var svg;\n/** @type {Object} */ var projection;\n/** @type {Object} */ var projectionPath;\n/** @type {Object} */ var currentData;\n\n// -----------------------------------------------------------------------------\n\n/**\n * Start the app. Call this function from a script element at the end of the html-doc.\n * @param _caseStudy {string} The initial case study object as initialized in the\n *                            init.js files for each case study.\n */\nfunction startApp(caseStudy) {\n  // assert that SVG is supported by the browser:\n  if (!document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\")) {\n    alert('SVG is not supported in your browser. Please use a recent browser.');\n    return;\n  }\n\n  d3.select(\"#radar-anchor-radius\").text(radarAnchorRadius);\n\n  // load the case study data:\n  caseStudy.load(function () {\n    //console.log(caseStudy);\n\n    // The initial focus:\n    focus = enram.focus(\n      caseStudy.defaultFocusFrom,\n      defaultFocusDuration,\n      caseStudy.defaultStrataOption,\n      caseStudy.defaultMigrantsPerPath\n    );\n    focus.constrain(caseStudy);\n\n    d3.select(\"#path-bird-count\").text(numeral(focus.migrantsPerPath).format('0,0'));\n\n    // parse the url query:\n    var urlQuery = {};\n    location.search.replace('\\?','').split('&').map(function (nvPair) {\n      nvPair = nvPair.split('=');\n      urlQuery[nvPair[0]] = nvPair[1];\n    });\n    if (urlQuery[\"strata-count\"]) {\n      setStrataCount(parseInt(urlQuery[\"strata-count\"]));\n    }\n    else if (urlQuery.altBands) {  // legacy\n      setStrataCount(urlQuery.altBands);\n    }\n    if (urlQuery[\"single-path\"]) {\n      singlePath = urlQuery[\"single-path\"] == \"true\";\n    }\n    if (urlQuery[\"length\"]) {\n      defaultFocusDuration = parseInt(urlQuery[\"length\"]);\n    }\n\n    var busy = 2;\n\n    // load the topography:\n    d3.json(caseStudy.topoJsonUrl, function (error, json) {\n      if (error) {\n        console.error(error);\n        return;\n      }\n      caseStudy.topoJson = json;\n      if (--busy == 0) initDone(caseStudy);\n    });\n\n    //updateAnchors();\n    updateColors(caseStudy, focus);\n\n    anchorArea = caseStudy.anchorInterval * caseStudy.anchorInterval;\n\n    if (--busy == 0) initDone(caseStudy);\n  });\n}\n\n/**\n * This function assumes that seconds and milliseconds are zero.\n * @param from {moment}\n * @param focus {enram.focus}\n * @param caseStudy {enram.caseStudy}\n * @returns {moment}\n */\nfunction constrainFrom(from, focus, caseStudy) {\n  if (from.isBefore(caseStudy.dataFrom)) {\n    from.date(caseStudy.dataFrom.date());\n    from.hour(caseStudy.dataFrom.hour());\n    from.minute(caseStudy.dataFrom.minute());\n    return from;\n  }\n  var till = moment(from).add(focus.duration, 'hours');\n  if (!till.isBefore(caseStudy.dataTill)) {\n    from.date(caseStudy.dataTill.date());\n    from.hour(caseStudy.dataTill.hour() - focus.duration);\n    from.minute(caseStudy.dataTill.minute());\n  }\n  return from;\n}\n\nfunction initDone(caseStudy) {\n\n  function dateUpdateHandler() {\n    var inputDay = d3.select(\"#input-day\");\n    var inputHour = d3.select(\"#input-hour\");\n\n    // derive and constrain new focus from moment:\n    var newFocusFrom = moment(focus.from);\n    newFocusFrom.date(parseInt(inputDay.property('value')));\n    newFocusFrom.hour(parseInt(inputHour.property('value')));\n    constrainFrom(newFocusFrom, focus, caseStudy);\n\n    // update the input widget to the constrained values:\n    inputDay.property('value', newFocusFrom.date());\n    inputHour.property('value', newFocusFrom.hour());\n    d3.select(\"#focus-month\").text(focus.from.format(\"MMM\"));\n    d3.select(\"#focus-year\").text(focus.from.format(\"YYYY\"));\n\n    // update focus and view if focus has changed:\n    if (!newFocusFrom.isSame(focus.from)) {\n      focus.setFrom(newFocusFrom);\n      updateVisualisation(caseStudy, focus, true, false);\n    }\n  }\n\n  function durationUpdateHandler() {\n    var inputDuration = d3.select(\"#input-length\");\n    var newDuration = parseInt(inputDuration.property('value'));\n    if (newDuration != focus.duration) {\n      focus.setDuration(newDuration);\n      updateVisualisation(caseStudy, focus, true, false);\n    }\n  }\n\n  function strataCountUpdateHandler() {\n    var newStrataOptionIdx = d3.select(\"#input-strata\").property('value');\n    if (newStrataOptionIdx != focus.strataOptionIdx) {\n      //console.log(\"input-strata changed:\", newStrataOptionIdx);\n      setStrataOptionIdx(newStrataOptionIdx);\n      updateColors(caseStudy, focus);\n      updateVisualisation(caseStudy, focus, true, true);\n    }\n  }\n\n  function migrantsPerPathUpdateHandler() {\n    var newMPP = d3.select(this).property('value');\n    if (newMPP != focus.migrantsPerPath) {\n      //console.log(\"input-migrants-per-path changed:\", newMPP);\n      setMigrantsPerPath(newMPP);\n      updateVisualisation(caseStudy, focus, false, false);\n    }\n  }\n\n  // configure the date input widgets:\n  d3.select(\"#input-day\")\n    .property('value', focus.from.date())\n    //.attr('min', caseStudy.dataFrom.date())\n    //.attr('max', moment(caseStudy.dataTill).subtract(1, 'minute').date())\n    .on('change', dateUpdateHandler);\n  d3.select(\"#focus-month\").text(focus.from.format(\"MMM\"));\n  d3.select(\"#focus-year\").text(focus.from.format(\"YYYY\"));\n  d3.select(\"#input-hour\")\n    .property('value', focus.from.hour())\n    .on('change', dateUpdateHandler);\n\n  // configure the duration input widget:\n  d3.select(\"#input-length\")\n    .property('value', focus.duration)\n    .on('change', durationUpdateHandler);\n\n  // configure the strata-count input widget:\n  d3.select(\"#input-strata\")\n    .selectAll('option')\n    .data(caseStudy.strataOptions)\n    .enter().append(\"option\")\n    .property('value', function (strataOption, i) { return i; })\n    .text(function (strataOption) { return strataOption.length; });\n  d3.select(\"#input-strata\")\n    .property('value', caseStudy.defaultStrataOption)\n    .on('change', strataCountUpdateHandler);\n\n  // configure the migrants-per-path input widget:\n  d3.select(\"#input-migrants-per-path\")\n    .selectAll('option')\n    .data(migrantsPerPathOptions)\n    .enter().append(\"option\")\n    .property(\"value\", function (d) { return d.value; })\n    //.property(\"selected\", function(d) { return d === focus.migrantsPerPath; })\n    .text(function (d) { return d.text; });\n  d3.select(\"#input-migrants-per-path\")\n    .property('value', focus.migrantsPerPath)\n    .on('change', migrantsPerPathUpdateHandler);\n\n  // set resize handler that updates the visualisation:\n  d3.select(window)\n    .on('resize', Foundation.utils.throttle(function(e) {\n      if (d3.select(\"#map-container\").node().getBoundingClientRect().width != mapW) {\n        updateVisualisation(caseStudy, focus, false, true);\n      }\n    }, 25));\n\n  // First update the map data and add the svg element to avoid miscalculation\n  // of the actual size of the svg content (on Chrome).\n  updateMapData(caseStudy);\n\n  // Now update the map for real:\n  updateVisualisation(caseStudy, focus, true, true);\n}\n\n/**\n * Use this function to update the strata-option value.\n * @param {number} strataOptionIdx\n */\nfunction setStrataOptionIdx(strataOptionIdx) {\n  focus.strataOptionIdx = strataOptionIdx;\n}\n\n/**\n * Use this function to update the migrants-per-path value.\n * @param {number} migrantsPerPath\n */\nfunction setMigrantsPerPath(migrantsPerPath) {\n  focus.migrantsPerPath = migrantsPerPath;\n  d3.select(\"#path-bird-count\").text(numeral(migrantsPerPath).format('0,0'));\n}\n\n/**\n * Prepare the hues for the altitude strata.\n * @param caseStudy {enram.caseStudy}\n * @param focus {enram.focus}\n */\nfunction updateColors(caseStudy, focus) {\n  caseStudy.hues = [];\n  caseStudy.altHexColors = [];\n  var altn = focus.strataCount(caseStudy);\n  var hue;\n  if (altn == 1) {\n    hue = (altiHueMin + altiHueMax) / 2;\n    caseStudy.hues.push(hue);\n    caseStudy.altHexColors.push(utils.hsvToHex(hue, altiSaturation, altiBrightness));\n  }\n  else {\n    for (var alti = 0; alti < altn; alti++) {\n      hue = utils.mapRange(alti, 0, altn - 1, altiHueMin, altiHueMax);\n      caseStudy.hues.push(hue);\n      caseStudy.altHexColors.push(utils.hsvToHex(hue, altiSaturation, altiBrightness));\n    }\n  }\n}\n\n/**\n * @param caseStudy {enram.caseStudy}\n * @param focus {enram.focus}\n * @param dataDirty {boolean}\n * @param mapDirty {boolean}\n */\nfunction updateVisualisation(caseStudy, focus, dataDirty, mapDirty) {\n  if (mapDirty) updateMapData(caseStudy);\n\n  // create/replace svg object:\n  if (svg) { svg.remove(); }\n  svg = d3.select(\"#map-container\").append(\"svg\")\n    .attr(\"width\", mapW)\n    .attr(\"height\", mapH)\n    .classed(\"visualisation\", true);\n\n  svg.append(\"defs\")\n    .append(\"clipPath\")\n    .attr(\"id\", \"clipRect\")\n    .append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", mapW)\n    .attr(\"height\", mapH);\n\n  var clipG = svg.append(\"g\");\n  clipG.attr(\"style\", \"clip-path: url(#clipRect);\");\n  if (arty) {\n    clipG.attr(\"style\", \"background: #fff;\");\n  }\n  else {\n    var mapG = clipG.append(\"g\").attr(\"id\", \"map\");\n    drawMap(mapG, caseStudy);\n  }\n\n  var pathsG = clipG.append(\"g\").attr(\"id\", \"paths\");\n  if (dataDirty) {\n    // A clone of the focus is passed to the loader. This focus will be set\n    // as focus property on the resulting data object.\n    caseStudy.loadFocusData(focus.clone(), function (data) {\n      //console.log(data);\n      currentData = data;\n      drawPaths(data, pathsG);\n    });\n  }\n  else {\n    currentData.focus = focus;\n    drawPaths(currentData, pathsG);\n  }\n\n  if (!arty) {\n    // draw legends:\n    var legendG = clipG.append(\"g\").attr(\"id\", \"color-legend\");\n    drawColorLegend(caseStudy, focus, legendG);\n\n    legendG = clipG.append(\"g\").attr(\"id\", \"scale-legend\");\n    drawScaleLegend(caseStudy, legendG, caseStudy.scaleLegendMarkers);\n\n    writeMetaData(caseStudy, focus, clipG);\n  }\n}\n\nfunction updateMapData(caseStudy) {\n  var svgRect = d3.select(\"#map-container\").node().getBoundingClientRect();\n  mapW = svgRect.width;\n  //console.log(\"- mapW:\", mapW);\n  mapH = mapW * mapHeightFactor;\n  legendW = mapW * legendWidthFactor;\n\n  // specify the projection based of the size of the map:\n  projection = caseStudy.getProjection(caseStudy, mapW, mapH);\n\n  // initialize the d3 path with which to draw the geography:\n  projectionPath = d3.geo.path().projection(projection);\n\n  caseStudy.radars.forEach(function (radar) {\n    radar.projection = projection(radar.location);\n  });\n\n  initAnchors(caseStudy);\n}\n\n/** Initialize the anchors. */\nfunction initAnchors(caseStudy) {\n  var locTopLeft = projection.invert([0, 0]);  // the location at the top-left corner\n  var locBotRight = projection.invert([mapW, mapH]);  // the loc. at the bottom-right\n  var rra = utils.geo.distAngle(radarAnchorRadius);  // radar radius as angle\n  var dlon = utils.geo.destination(caseStudy.mapCenter, 90, caseStudy.anchorInterval)[0]\n    - caseStudy.mapCenter[0];  // longitude delta\n  var dlat = utils.geo.destination(caseStudy.mapCenter, 0, caseStudy.anchorInterval)[1]\n    - caseStudy.mapCenter[1];  // latitude delta\n  anchorLocations = [];\n  for (var lon = locTopLeft[0]; lon < locBotRight[0]; lon += dlon) {\n    for (var lat = locTopLeft[1]; lat > locBotRight[1]; lat -= dlat) {\n      caseStudy.radars.forEach(function (radar) {\n        if (utils.degrees(d3.geo.distance(radar.location, [lon, lat])) <= rra) {\n          anchorLocations.push([lon, lat]);\n        }\n      });\n    }\n  }\n}\n\nfunction drawMap(mapG, caseStudy) {\n  mapG.append(\"rect\")\n    .attr(\"id\", \"background\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", mapW)\n    .attr(\"height\", mapH);\n  mapG.append(\"path\")\n    .attr(\"id\", \"land\")\n    .datum(topojson.feature(\n      caseStudy.topoJson,\n      caseStudy.topoJson.objects.countries\n    ))\n    .attr(\"d\", projectionPath);\n  mapG.append(\"path\")\n    .attr(\"id\", \"country-boundary\")\n    .datum(topojson.mesh(\n      caseStudy.topoJson,\n      caseStudy.topoJson.objects.countries,\n      function(a, b) { return a !== b; }\n    ))\n    .attr(\"d\", projectionPath);\n  mapG.append(\"path\")\n    .attr(\"id\", \"graticule\")\n    .datum(d3.geo.graticule().step([1, 1]))\n    .attr(\"d\", projectionPath);\n\n  // draw radars:\n  var rra = utils.geo.distAngle(radarAnchorRadius); // radar radius as angle:\n  var radarG = mapG.append(\"g\").attr(\"id\", \"radars\");\n  if (showRadarLabels) {\n    var radarLabelsG = mapG.append(\"g\").attr(\"id\", \"radar-labels\");\n  }\n  caseStudy.radars.forEach(function (radar) {\n    radarG.append(\"path\")\n      .attr(\"id\", \"radar-radius\")\n      .datum(d3.geo.circle().origin(radar.location).angle(rra))\n      .attr(\"d\", projectionPath);\n\n    if (showRadarLabels) {\n      var rp = projection(radar.location);\n      radarLabelsG.append('circle')\n        .attr('cx', rp[0])\n        .attr('cy', rp[1])\n        .attr('r', 1.5)\n        .classed(\"radar-center\", true);\n      radarLabelsG\n        .append(\"text\")\n        .attr(\"x\", rp[0] + 4)\n        .attr(\"y\", rp[1] + 10)\n        .text(radar.id)\n        .classed(\"radar-label\", true);\n    }\n\n    // Draw series points around radar at the marker radius:\n    //var n = 36;\n    //for (var i = 0; i < n; i++) {\n    //  var bearing = utils.mapRange(i, 0, n, 0, 360);\n    //  var dest = utils.geo.destination(radar.location, bearing, radarAnchorRadius);\n    //  radarG.append(\"path\")\n    //    .datum(d3.geo.circle().origin(dest).angle(.01))\n    //    .attr(\"d\", projectionPath)\n    //    .classed(\"highlight3\", true);\n    //}\n  });\n}\n\n/**\n * Draw the paths.\n */\nfunction drawPaths(data, pathsG) {\n  if (singlePath) {\n    drawPaths_singlePath(data, pathsG);\n  }\n  else {\n    drawPaths_multiPath(data, pathsG);\n  }\n}\n\n// Debug\n//var debugAnchorId = 540;\n//function anchorId(anchorLoc) {\n//  return anchorLocations.indexOf(anchorLoc);\n//}\n//function isDebug(anchorLoc) {\n//  return anchorLoc == anchorLocations[debugAnchorId];\n//}\n\n/**\n * @param data {timamp.dataObject}\n * @param pathsG {svg.g}\n */\nfunction drawPaths_multiPath(data, pathsG) {\n  //console.log(\">> app.drawPaths_multiPath\");\n  Math.seedrandom('ENRAM');\n  var rlons = data.caseStudy.radLons;\n  var rlats = data.caseStudy.radLats;\n  var idw = utils.idw;\n  var strn = data.strataCount;\n  var radiusFactor = 0.05;\n  var probf = anchorArea / data.focus.migrantsPerPath;\n  for (var stri = 0; stri < strn; stri++) {\n    try {\n      var densities = data.avDensities[stri]; // birds/km2 in the strata\n    }\n    catch (error) {\n      console.error(\"- stri: \" + stri);\n      console.error(\"- strn: \" + strn);\n      console.error(\"- data.avDensities: \" + data.avDensities);\n      throw (error);\n    }\n\n    anchorLocations.forEach(function (anchorLoc) {\n      try {\n        var density = idw(anchorLoc[0], anchorLoc[1], densities, rlons, rlats, 2);\n      }\n      catch (error) {\n        console.error(\"- anchorLoc: \" + anchorLoc);\n        throw (error);\n      }\n\n      // Only continue for a subset of anchor locations, selected by a probability based\n      // on the average density:\n      if (Math.random() < density * probf) {\n        //console.log(\"- active anchorId(anchorLoc): \" + anchorId(anchorLoc));\n\n        var pathData = timamp.buildPathData(data, stri, anchorLoc);\n        if (pathData.length == 0) {\n          //console.log(\"got empty pathData\");\n          return;\n        }\n\n        var lineData = timamp.buildOutline(pathData, radiusFactor);\n        var flowG = pathsG.append(\"g\").classed(\"flow-line\", true);\n        var lcolor = data.caseStudy.altHexColors[stri];\n        drawPath_variableThickness(flowG, pathData, lineData, stri, radiusFactor, lcolor);\n\n        // DEBUG:\n        //if (isDebug(anchorLoc)) {\n        //  console.log(pathData);\n        //  flowG.select(\"path\").style(\"fill\", \"#f00\");\n        //}\n      }\n    });\n  }\n}\n\nfunction drawPaths_singlePath(data, pathsG) {\n  var strn = data.strataCount;\n  var tdy = Math.min(12 * strn, 150);\n  var radiusFactor = 0.05;\n  for (var stri = 0; stri < strn; stri++) {\n    data.caseStudy.radars.forEach(function (radar, radi) {\n      var oy = utils.mapRange(stri, 0, strn - 1, tdy / 2, -tdy / 2);\n      // draw anchor marks:\n      pathsG.append('circle')\n        .attr('cx', radar.projection[0])\n        .attr('cy', radar.projection[1] + oy)\n        .attr('r', 1)\n        .classed(\"acchor\", true);\n      if (data.avDensities[stri][radi] == 0) {\n        return;  // do not draw empty paths\n      }\n      var pathData = buildPathData_singlePath(data, stri, radi, radar.location);\n      pathData = pathData.map(function (d) {\n        return [d[0], d[1] + oy, d[2], d[3]];\n      });\n      var lineData = timamp.buildOutline(pathData, radiusFactor);\n      var lcolor = data.caseStudy.altHexColors[stri];\n      drawPath_variableThickness(pathsG.append(\"g\"),\n        pathData, lineData, stri, radiusFactor, lcolor);\n    });\n  }\n}\n\nfunction buildPathData_singlePath(data, stri, radi, anchorLoc) {\n  var pathData = [];\n  var segi, segn = data.segmentCount;\n  var loc, dlon, dlat, pp, angl, dist, dens;\n  var tf1 = data.caseStudy.segmentSize * 0.06;  // 0.06 = 60 sec. * 0.001 km/m\n  var half = Math.floor(data.segmentCount / 2);\n\n  // tail half:\n  loc = anchorLoc;\n  pp = projection(loc);\n  for (segi = half - 1; segi >= 0; segi--) {\n    dlon = data.uSpeeds[segi][stri][radi] * tf1;\n    dlat = data.vSpeeds[segi][stri][radi] * tf1;\n    angl = Math.atan2(-dlon, -dlat);\n    dist = utils.vectorLength(dlon, dlat);\n    loc = utils.geo.destinationRad(loc, angl, dist);\n    dens = data.densities[segi][stri][radi];\n    pp = projection(loc);\n    pp.push(dens, angl + Math.PI);\n    pathData.unshift(pp);\n  }\n\n  // front half:\n  loc = anchorLoc;\n  pp = projection(loc);\n  for (segi = half; segi < segn; segi++) {\n    pp = projection(loc);\n    dens = data.densities[segi][stri][radi];\n    dlon = data.uSpeeds[segi][stri][radi] * tf1;\n    dlat = data.vSpeeds[segi][stri][radi] * tf1;\n    angl = Math.atan2(dlon, dlat);\n    pp.push(dens, angl);\n    pathData.push(pp);\n    dist = utils.vectorLength(dlon, dlat);\n    loc = utils.geo.destinationRad(loc, angl, dist);\n  }\n\n  pp = projection(loc);\n  pp.push(dens, 0);  // same density as last segment\n  pathData.push(pp);\n\n  return pathData;\n}\n\nvar lineFn = d3.svg.line()\n  .x(function (d) { return d[0]; })\n  .y(function (d) { return d[1]; })\n  .interpolate(\"cardinal-closed\");\n\nfunction drawPath_fixedThickness(data, pathG, pathData, stri) {\n  var lcolor = caseStudy.altHexColors[stri];\n  var segi, segn = data.segmentCount;\n  for (segi = 0; segi < segn; segi++) {\n    var node1 = pathData[segi];\n    var node2 = pathData[segi + 1];\n    var dens = (node1[2] + node2[2]) / 2;\n    var lwidth = utils.mapRange(dens, 0, 100, 0, 10);\n    //console.log(node1, node2, dens, lwidth, lcolor);\n    pathG.append(\"line\")\n      .attr(\"x1\", node1[0]).attr(\"y1\", node1[1])\n      .attr(\"x2\", node2[0]).attr(\"y2\", node2[1])\n      .attr(\"style\", \"stroke:\" + lcolor\n      + \";stroke-width: \" + lwidth\n      + \";stroke-linecap: round\"\n      + \";opacity: 1\");\n  }\n}\n\nfunction drawPath_variableThickness(flowG, pathData, lineData, stri, radiusFactor, lcolor) {\n  //console.log(lineData.map(function (d) {\n  //  return '[' + d[0] + ', ' + d[1] + ']';\n  //}));\n  var segn = pathData.length - 1;\n  var radius;\n\n  // draw paths:\n  var opacity = arty ? .6 : .7;\n  flowG.append(\"path\")\n    .attr(\"d\", lineFn(lineData))\n    .style({fill: lcolor, \"fill-opacity\": opacity });\n\n  // draw head dot:\n  if (arty) {\n    radius = 0;\n    pathData.forEach(function (d) { radius += d[2]; });\n    radius = Math.max(1, radius / pathData.length);\n    opacity = .5;\n  }\n  else {\n    radius = utils.constrain(pathData[segn][2] * radiusFactor + .5, 1.5, 3);\n    opacity = 1;\n  }\n  flowG.append('circle')\n    .attr('cx', pathData[segn][0])\n    .attr('cy', pathData[segn][1])\n    .attr('r', radius)\n    .attr(\"style\", \"fill: \" + lcolor + \"; fill-opacity: \" + opacity + \";\");\n}\n\n/**\n * Draws the color legend in a horizontal layout.\n * @param caseStudy {enram.caseStudy}\n * @param focus {enram.focus}\n * @param legendG\n */\nfunction drawColorLegend_hor(caseStudy, focus, legendG) {\n  var legendH = 12;\n  var legendL = 25;\n  //var tx0 = legendL;\n  //var td = 6;\n  var ty = mapH - 20 - legendH - 8;\n  var markerGr = legendG.append(\"g\");\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", legendL)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"0\");\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", legendL + legendW / 2)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"2\");\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", legendL + legendW + 6)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"4 km\");\n\n  var lineH = 7;\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendL)\n    .attr(\"y1\", mapH - 20 - legendH - lineH)\n    .attr(\"x2\", legendL)\n    .attr(\"y2\", mapH - 20);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendL + legendW / 2)\n    .attr(\"y1\", mapH - 20 - legendH - lineH)\n    .attr(\"x2\", legendL + legendW / 2)\n    .attr(\"y2\", mapH - 20);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendL + legendW)\n    .attr(\"y1\", mapH - 20 - legendH - lineH)\n    .attr(\"x2\", legendL + legendW)\n    .attr(\"y2\", mapH - 20);\n\n  var tx = legendL;\n  ty = mapH - 20 - legendH;\n  var alti, altn = focus.strataCount(caseStudy);\n  var dx = legendW / altn;\n  for (alti = 0; alti < altn; alti++) {\n    legendG.append(\"rect\")\n      .attr(\"x\", tx)\n      .attr(\"y\", ty)\n      .attr(\"width\", Math.ceil(dx))\n      .attr(\"height\", legendH)\n      .attr(\"style\", \"fill:\" + caseStudy.altHexColors[alti] + \";\");\n    tx += dx;\n  }\n}\n\n/**\n * Draws the color legend in a vertical layout.\n * @param caseStudy {enram.caseStudy}\n * @param focus {enram.focus}\n * @param legendG\n */\nfunction drawColorLegend(caseStudy, focus, legendG) {\n  var margin = 20;\n  var legendW = 12;\n  var legendH = 100;\n  var legendT = margin;\n\n  var altitudeRange = focus.altitudeRange(caseStudy);\n  var minHeight = altitudeRange[0] / 1000;\n  var midHeight = (altitudeRange[0] + altitudeRange[1]) / 2000;\n  var maxHeight = altitudeRange[1] / 1000;\n\n  var ty = legendT;\n  var alti, altn = focus.strataCount(caseStudy);\n  var dy = legendH / altn;\n  for (alti = altn - 1; alti >= 0; alti--) {\n    legendG.append(\"rect\")\n      .attr(\"x\", margin)\n      .attr(\"y\", ty)\n      .attr(\"width\", legendW)\n      .attr(\"height\", Math.ceil(dy))\n      .attr(\"style\", \"fill:\" + caseStudy.altHexColors[alti] + \";\");\n    ty += dy;\n  }\n\n  var lineW = 7;\n  var x2 = margin + legendW + lineW;\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", margin)\n    .attr(\"y1\", legendT)\n    .attr(\"x2\", x2)\n    .attr(\"y2\", legendT);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", margin + legendW)\n    .attr(\"y1\", legendT + legendH / 2)\n    .attr(\"x2\", x2)\n    .attr(\"y2\", legendT + legendH / 2);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", margin)\n    .attr(\"y1\", legendT + legendH)\n    .attr(\"x2\", x2)\n    .attr(\"y2\", legendT + legendH);\n\n  var x2 = margin + legendW + lineW + 4;\n  legendG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", x2)\n    .attr(\"y\", legendT + 8)\n    .text(maxHeight + \"km\");\n  legendG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", x2)\n    .attr(\"y\", legendT + legendH / 2 + 4)\n    .text(midHeight + \" km\");\n  legendG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", x2)\n    .attr(\"y\", legendT + legendH)\n    .text(minHeight + \" km\");\n  legendG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin + legendW + lineW + 2)\n    .attr(\"y\", legendT + legendH + 12)\n    .text(\"altitude\");\n}\n\n/**\n * Draws the scale legend.\n * @param caseStudy {enram.caseStudy}\n * @param legendG\n * @param markers\n */\nfunction drawScaleLegend(caseStudy, legendG, markers) {\n  var totalKm = markers[2];\n  var radar = caseStudy.radars[0];\n  var destProj = projection(utils.geo.destination(radar.location, 90, totalKm));\n  var legendW = destProj[0] - projection(radar.location)[0];\n  var marginR = 45;\n  var legendL = mapW - marginR - legendW;\n  var legendR = mapW - marginR;\n  var lineH = 7;\n  var ty = mapH - 20 - lineH - 4;\n\n  var markerGr = legendG.append(\"g\");\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", legendL)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"0\");\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", (legendL + legendR) / 2)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(markers[1]);\n  markerGr.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", legendR + 8)\n    .attr(\"y\", ty)\n    .attr(\"text-anchor\", \"middle\")\n    .text(markers[2] + \" km\");\n\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendL)\n    .attr(\"y1\", mapH - 20)\n    .attr(\"x2\", legendR)\n    .attr(\"y2\", mapH - 20);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendL)\n    .attr(\"y1\", mapH - 20 - lineH)\n    .attr(\"x2\", legendL)\n    .attr(\"y2\", mapH - 20);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", (legendL + legendR) / 2)\n    .attr(\"y1\", mapH - 20 - lineH)\n    .attr(\"x2\", (legendL + legendR) / 2)\n    .attr(\"y2\", mapH - 20);\n  legendG.append(\"line\")\n    .classed(\"scale-legend-line\", true)\n    .attr(\"x1\", legendR)\n    .attr(\"y1\", mapH - 20 - lineH)\n    .attr(\"x2\", legendR)\n    .attr(\"y2\", mapH - 20);\n}\n\n/**\n * @param caseStudy {enram.caseStudy}\n * @param focus {enram.focus}\n * @param clipG\n */\nfunction writeMetaData(caseStudy, focus, clipG) {\n  if (!writeMetaDataInViz) return;\n\n  var mdG = clipG.append(\"g\").attr(\"id\", \"meta-data\");\n  var margin = 18;\n  var lh = 12;\n  var ly = mapH - 7 - 3 * lh;\n  var formatString = \"HH[h], MMM D, YYYY\";\n  var tillMoment = moment(focus.from).add(focus.duration, \"hours\");\n\n  mdG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin)\n    .attr(\"y\", ly)\n    .text(\"From:\");\n  mdG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin + 35)\n    .attr(\"y\", ly)\n    .text(focus.from.format(formatString));\n\n  ly += lh;\n  mdG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin)\n    .attr(\"y\", ly)\n    .text(\"Till:\");\n  mdG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin + 35)\n    .attr(\"y\", ly)\n    .text(tillMoment.format(formatString));\n\n  ly += lh;\n  mdG.append(\"text\")\n    .classed(\"legend-label\", true)\n    .attr(\"x\", margin)\n    .attr(\"y\", ly)\n    .text(\"Migrants per line: \" + focus.migrantsPerPath);\n}\n\n","/**\n * Created by wouter on 28/11/2015.\n */\n\n/**\n * caseStudy form:\n * {\n     *   <see properties in README.md>\n     *   defaultFocusFrom: {moment}\n     *   segmentCount: {number} The number of segments in the source data\n     * }\n *\n * @param basePath {String}\n * @param dataService {object}\n * @returns The caseStudy object.\n */\nenram.caseStudy = function (basePath, dataService) {\n  var caseStudy = {\n    basePath: basePath,\n    dataService: dataService,\n    isCaseStudy: true\n  };\n\n  /**\n   * Asynchronously loads the case study metadata and other necessary data.\n   * @param handler\n   */\n  caseStudy.load = function (handler) {\n    this.loadMetaData(function () {\n      this.dataService.initialize(caseStudy, handler);\n    });\n  };\n\n  /**\n   * Load case study data from properly formatted json file.\n   * @param handler {function(Object)} Called when loading is complete.\n   */\n  caseStudy.loadMetaData = function (handler) {\n    //console.log(this);\n    caseStudy.urlBase = \"src/data/\" + this.basePath + \"/\";\n    d3.json(caseStudy.urlBase + \"metadata.json\", function (error, json) {\n      if (error) {\n        throw new Error(\"Error loading metadata.json in \" + caseStudy.urlBase +\n          + \" in caseStudy.loadMetaData(). \" + error);\n            //+ JSON.parse(error.responseText).error.join(\"; \"));\n      }\n\n      for (var attr in json) {\n        if (json.hasOwnProperty(attr)) caseStudy[attr] = json[attr];\n      }\n      caseStudy.dataFrom = moment.utc(caseStudy.dataFrom);\n      caseStudy.dataTill = moment.utc(caseStudy.dataTill);\n      caseStudy.defaultFocusFrom = moment.utc(caseStudy.defaultFocusFrom);\n\n      // Create mapping from radar ids to indices:\n      caseStudy.radarIndices = {};\n      caseStudy.radLons = [];\n      caseStudy.radLats = [];\n      caseStudy.radars.forEach(function (radar, i) {\n        radar.location = [radar.longitude, radar.latitude];\n        caseStudy.radarIndices[radar.id] = i;\n        caseStudy.radLons.push(radar.longitude);\n        caseStudy.radLats.push(radar.latitude);\n      });\n\n      caseStudy.selectedRadar = caseStudy.radars[0];\n      caseStudy.radarCount = caseStudy.radars.length;\n\n      caseStudy.strataOptions.forEach(function (strataOption) {\n        strataOption.forEach(function (strata) {\n          strata.push(strata[1] - strata[0]);\n        })\n      });\n\n      caseStudy.topoJsonUrl = caseStudy.urlBase + \"topo.json\";\n      //console.log(caseStudy.topoJsonUrl);\n\n      console.info(\"Loaded case study\", caseStudy.label);\n      handler.call(caseStudy);\n    });\n  };\n\n  /**\n   * Loads the data for the given focus.\n   * @param focus    {enram.focus}\n   * @param handler  {function(dataObject)}  called when the data is loaded\n   */\n  caseStudy.loadFocusData = function (focus, handler) {\n    //console.log(\">> caseStudy.loadFocusData()\");\n    this.dataService.loadFocusData(this, focus, handler);\n  };\n\n  /**\n   * @return the number of strata for the different strata options.\n   */\n  caseStudy.strataCounts = function () {\n    if (this.__strataCounts == undefined) {\n      this.__strataCounts = this.strataOptions.map(function (strataOption) {\n        return strataOption.length;\n      });\n    }\n    return this.__strataCounts;\n  };\n  caseStudy.__strataCounts = undefined;\n\n  /**\n   * @return the segment duration in milliseconds\n   */\n  caseStudy.segmentMillis = function () {\n    return this.segmentSize * 60 * 1000;\n  };\n\n  caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n    console.error(\"There is no implementation for getProjection in case study '\" + basePath + \"'.\");\n  };\n\n  return caseStudy;\n\n};\n","/**\n * Created by wouter on 13/12/2015.\n */\n\nvar timamp = (function () {\n\n  var timamp = {};\n\n  // pathData indices:\n  var pdi_x = 0;\n  var pdi_y = 1;\n  var pdi_density = 2;\n  var pdi_angle = 3;\n  var pdi_location = 4;\n  var pdi_distance = 5;\n\n  /**\n   * The timamp data structure is constructed such that it efficiently facilitates\n   * the interpolation operations needed when constructing the paths in the timamp\n   * visualization.\n   *\n   * Terminology:\n   * - segment : The data is temporally segmented in segments of e.g. 20 minutes.\n   * - focus : A temporal section of the data currently shown in the visualisation.\n   * - strata : An altitude range.\n   *\n   * This data structure should always be complete, meaning that for each segment in the\n   * focus window, for each strata and for each radar, there should be a value, even\n   * if the original data does not fully cover the given focus window.\n   *\n   * The data object has the following form:\n   * {\n     *   caseStudy: {enram.caseStudy},  // the caseStudy\n     *   focus: {enram.focus},    // specifies the focus start and duration\n     *   segmentCount: {number},  // the number of segments in the focus\n     *   densities: {Array},      // matrix with dimensions: [segment, strata, radar]\n     *   uSpeeds: {Array},        // matrix with dimensions: [segment, strata, radar]\n     *   vSpeeds: {Array},        // matrix with dimensions: [segment, strata, radar]\n     *   speeds: {Array},         // matrix with dimensions: [segment, strata, radar]\n     *   avDensities: {Array},    // matrix with dimensions: [strata, radar]\n     * }\n   *\n   * @param caseStudy  {enram.caseStudy}\n   * @param focus      {enram.focus}\n   * @returns the data structure\n   */\n  timamp.dataObject = function (caseStudy, focus) {\n    var dataObject = {\n      caseStudy: caseStudy,\n      focus: focus,\n      __strataOption: focus.strataOption(caseStudy),\n      strataCount: focus.strataCount(caseStudy),\n      segmentCount: focus.segmentCount(caseStudy),\n      densities: [],\n      uSpeeds: [],\n      vSpeeds: [],\n      speeds: [],\n      avDensities: []\n    };\n\n    /**\n     * Initializes the data structure to be filled with actual data.\n     * @return the data object\n     */\n    dataObject.initStructure = function () {\n      var segn = this.segmentCount;\n      var strn = this.strataCount;\n      var radn = caseStudy.radarCount;\n      for (var segi = 0; segi < segn; segi++) {\n        var densities = [];\n        var uSpeeds = [];\n        var vSpeeds = [];\n        var speeds = [];\n        for (var stri = 0; stri < strn; stri++) {\n          densities.push(utils.zeroArray(radn));\n          uSpeeds.push(utils.zeroArray(radn));\n          vSpeeds.push(utils.zeroArray(radn));\n          speeds.push(utils.zeroArray(radn));\n        }\n        this.densities.push(densities);\n        this.uSpeeds.push(uSpeeds);\n        this.vSpeeds.push(vSpeeds);\n        this.speeds.push(speeds);\n      }\n\n      for (stri = 0; stri < strn; stri++) {\n        this.avDensities.push(utils.zeroArray(radn));\n      }\n\n      return this;\n    };\n\n    /**\n     * Returns the size (height) of the strata with the given index.\n     * @param strataIdx\n     * @returns {number}\n     */\n    dataObject.strataSize = function (strataIdx) {\n      return this.__strataOption[strataIdx][2] / 1000;\n    };\n\n    /**\n     * Prepends data entries to replace missing data for a given amount of segments.\n     * @param amount The number of segments for which to add data entries.\n     */\n    dataObject.prependMissingSegments = function (amount) {\n      // empty partial data structure to use in dataObject.addMissingSegments:\n      var missingSegmentData = [];\n      for (var stri = 0; stri < this.strataCount; stri++) {\n        missingSegmentData.push(utils.zeroArray(caseStudy.radarCount));\n      }\n\n      for (var i = 0; i < amount; i++) {\n        this.densities.unshift(missingSegmentData);\n        this.uSpeeds.unshift(missingSegmentData);\n        this.vSpeeds.unshift(missingSegmentData);\n        this.speeds.unshift(missingSegmentData);\n      }\n    };\n\n    /**\n     * Appends data entries to replace missing data for a given amount of segments.\n     * @param amount The number of segments for which to add data entries.\n     */\n    dataObject.appendMissingSegments = function (amount) {\n      // empty partial data structure to use in dataObject.addMissingSegments:\n      var missingSegmentData = [];\n      for (var stri = 0; stri < this.strataCount; stri++) {\n        missingSegmentData.push(utils.zeroArray(caseStudy.radarCount));\n      }\n\n      for (var i = 0; i < amount; i++) {\n        this.densities.push(missingSegmentData);\n        this.uSpeeds.push(missingSegmentData);\n        this.vSpeeds.push(missingSegmentData);\n        this.speeds.push(missingSegmentData);\n      }\n    };\n\n    return dataObject;\n  };\n\n  /**\n   * The resulting path is obtained through numerical integration from the anchor point, half\n   * backwards, half forwards. The integration is implemented using the 2-stage Runge–Kutta\n   * algorithm, also known as the Heun method, as represented in the following scheme:\n   *\n   *        a := k.u(p_i, t_i),\n   *        b := k.u(p_i + a, t_i + k)\n   *  p_(i+1) := p_i + 1/2(a + b)\n   *\n   * where:\n   * -       i : the current iteration index\n   * -     p_i : the position at index i\n   * -     t_i : the time at index i\n   * - u(x, t) : the velocity at position x and time t\n   * -       k : timestep\n   *\n   * Reference: Darmofal_96a (in README.md)\n   *\n   * @param data {timamp.dataObject}\n   * @param stri strata index\n   * @param anchorLoc anchor location\n   */\n  timamp.buildPathData = function (data, stri, anchorLoc) {\n    var pathData = [];\n    var rlons = data.caseStudy.radLons;\n    var rlats = data.caseStudy.radLats;\n    var idw = utils.idw;\n\n    // This value is multiplied with uSpeed/vSpeed values, expressed in m/s, in order\n    // to obtain the distance traveled during the segment interval, expressed in km.\n    // Note: data.caseStudy.segmentSize = the duration of a segment in minutes (e.g. 20 min).\n    var tf1 = data.caseStudy.segmentSize * 60 / 1000;\n\n    /**\n     * @param p_0 source position (in lat/lon)\n     * @param t_i source segment index\n     * @param s_i strata index\n     */\n    function stepBackward(p_0, t_i, s_i) {\n      var a_u = -idw(p_0[0], p_0[1], data.uSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      var a_v = -idw(p_0[0], p_0[1], data.vSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      var a_d = utils.vectorLength(a_u, a_v);  // distance a\n      var a_a = Math.atan2(a_u, a_v);         // angle a\n      var a_l = utils.geo.destinationRad(p_0, a_a, a_d);  // location p_0 + a\n      var b_u = -idw(a_l[0], a_l[1], data.uSpeeds[t_i - 1][s_i], rlons, rlats, 2) * tf1;\n      var b_v = -idw(a_l[0], a_l[1], data.vSpeeds[t_i - 1][s_i], rlons, rlats, 2) * tf1;\n      var f_u = (a_u + b_u) / 2;              // final u_distance\n      var f_v = (a_v + b_v) / 2;              // final v_distance\n      var f_d = utils.vectorLength(f_u, f_v);  // final distance\n      var f_a = Math.atan2(f_u, f_v);         // final angle\n      var f_l = utils.geo.destinationRad(p_0, f_a, f_d);  // final position p_0 + 1/2(a + b)\n      var den = idw(f_l[0], f_l[1], data.densities[t_i - 1][s_i], rlons, rlats, 2);\n      var dat = projection(f_l);  // projection of the location in pixel-space\n      dat.push(den, f_a + Math.PI, f_l, f_d, -f_u, -f_v, t_i - 1);\n      return dat;\n    }\n\n    function stepForward(p_0, t_i, s_i) {\n      var a_u, a_v, a_d, a_a, a_l, f_u, f_v, f_d, f_a, f_l, den, dat;\n      a_u = idw(p_0[0], p_0[1], data.uSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      a_v = idw(p_0[0], p_0[1], data.vSpeeds[t_i][s_i], rlons, rlats, 2) * tf1;\n      a_d = utils.vectorLength(a_u, a_v);  // distance a\n      a_a = Math.atan2(a_u, a_v);         // angle a\n      a_l = utils.geo.destinationRad(p_0, a_a, a_d);  // location p_0 + a\n      if (t_i + 1 >= data.densities.length) {\n        f_u = a_u;\n        f_v = a_v;\n        f_d = a_d;\n        f_a = a_a;\n        f_l = a_l;\n        den = idw(f_l[0], f_l[1], data.densities[t_i][s_i], rlons, rlats, 2);\n      }\n      else {\n        try {\n          var b_u = idw(a_l[0], a_l[1], data.uSpeeds[t_i + 1][s_i], rlons, rlats, 2) * tf1;\n          var b_v = idw(a_l[0], a_l[1], data.vSpeeds[t_i + 1][s_i], rlons, rlats, 2) * tf1;\n        }\n        catch (error) {\n          console.error(\"- a_l:\", a_l);\n          console.error(\"- t_i:\", t_i, \"s_i:\", s_i);\n          console.error(\"- data.uSpeeds:\", data.uSpeeds);\n          console.error(\"- data.uSpeeds[t_i + 1]:\", data.uSpeeds[t_i + 1]);\n          throw error;\n        }\n        f_u = (a_u + b_u) / 2;              // final u_distance\n        f_v = (a_v + b_v) / 2;              // final v_distance\n        f_d = utils.vectorLength(f_u, f_v);  // final distance\n        f_a = Math.atan2(f_u, f_v);         // final angle\n        f_l = utils.geo.destinationRad(p_0, f_a, f_d);  // final position p_0 + 1/2(a + b)\n        den = idw(f_l[0], f_l[1], data.densities[t_i + 1][s_i], rlons, rlats, 2);\n      }\n      dat = projection(f_l);  // projection of the location in pixel-space\n      dat.push(den, f_a, f_l, f_d, f_u, f_v, t_i + 1);\n      return dat;\n    }\n\n    var segn = Math.min(data.segmentCount, data.densities.length);\n    var half = Math.floor(data.segmentCount / 2);\n    var loc, d_u, d_v, dat, ang, dis, den;\n    //console.log(\"rlons:\", rlons, \"rlats:\", rlats, \"segn:\", segn);\n\n\n    // middle point on anchor position:\n    loc = anchorLoc;       // the current location, initially the location of the path's anchor\n    dat = projection(loc);  // projection of the location in pixel-space\n    try {\n      d_u = idw(loc[0], loc[1], data.uSpeeds[half][stri], rlons, rlats, 2) * tf1;  // interpolated u-speed\n    } catch (error) {\n      console.error(\"loc:\", loc);\n      console.error(\"data.uSpeeds:\", data.uSpeeds);\n      console.error(\"half:\", half);\n      console.error(\"data.uSpeeds[half]:\", data.uSpeeds[half]);\n      throw error;\n    }\n    d_v = idw(loc[0], loc[1], data.vSpeeds[half][stri], rlons, rlats, 2) * tf1;  // interpolated v-speed\n    den = idw(loc[0], loc[1], data.densities[half][stri], rlons, rlats, 2);      // interpolated density\n    ang = Math.atan2(d_u, d_v);         // angle\n    dis = utils.vectorLength(d_u, d_v);  // distance\n    dat.push(den, ang, loc, d_u, d_v, dis, \"anchor\");\n    pathData.push(dat);\n\n    //console.log(\"loc:\", loc, \"d_u:\", d_u, \"d_v:\", d_v);\n    //console.log(\"den:\", den, \"ang:\", ang, \"dis:\", dis, \"dat:\", dat);\n    //console.log(\"1:\", pathData);\n\n    // tail half, backwards from middle to first segment\n    for (segi = half; segi > 0; segi--) {\n      try {\n        dat = stepBackward(loc, segi, stri);\n      }\n      catch (error) {\n        console.error(\"- segi: \" + segi + \", segn: \" + segn + \", stri: \" + stri);\n        throw error;\n      }\n      pathData.unshift(dat);\n      loc = dat[pdi_location];\n    }\n\n    // front half, forwards from middle to last segment:\n    loc = anchorLoc;\n    for (segi = half; segi < segn; segi++) {\n      try {\n        dat = stepForward(loc, segi, stri);\n      }\n      catch (error) {\n        console.error(\"- segi: \" + segi + \", segn: \" + segn + \", stri: \" + stri);\n        throw error;\n      }\n      pathData.push(dat);\n      loc = dat[pdi_location];\n    }\n\n    // remove all data points with speed = 0:\n    var len = pathData.length;\n    var i = 0;\n    while (i < len) {\n      if (pathData[i][pdi_distance] == 0) {\n        pathData.splice(i, 1);\n        len--;\n      }\n      else {\n        i++;\n      }\n    }\n\n    // minimize angle delta between subsequent angles:\n    utils.minimizeAngleDelta(pathData.length,\n      function (idx) { return pathData[idx][pdi_angle]; },\n      function (idx, val) { pathData[idx][pdi_angle] = val; }\n    );\n\n    //DEBUG:\n    //if (anchorLoc == anchorLocations[DEBUG_ANCHOR_IDX]) {\n    //  var densities = [];\n    //  var angles = [];\n    //  var uSpeeds = [];\n    //  var vSpeeds = [];\n    //  var speeds = [];\n    //  var segs = [];\n    //  pathData.forEach(function (ary) {\n    //    // [x, y, de, a2, l2, u2, v2, segi]\n    //    densities.push(ary[2]);\n    //    angles.push(ary[3]);\n    //    uSpeeds.push(ary[5]);\n    //    vSpeeds.push(ary[6]);\n    //    speeds.push(ary[7]);\n    //    segs.push(ary[8]);\n    //  });\n    //  console.log(\"pathData\", pathData);\n    //  console.log(\"densities\", densities);\n    //  console.log(\"angles\", angles);\n    //  console.log(\"uSpeeds\", uSpeeds);\n    //  console.log(\"vSpeeds\", vSpeeds);\n    //  console.log(\"speeds\", speeds);\n    //  console.log(\"segs\", segs);\n    //}\n\n    return pathData;\n  };\n\n  /**\n   * Generates the outline of a path whose variable width reflects the dynamic densities.\n   * @param pathData\n   * @param radiusFactor\n   * @returns {Array} [[<x>, <y>], ...]\n   */\n  timamp.buildOutline = function (pathData, radiusFactor) {\n    var lineData = [];\n    if (pathData.length == 0) { return lineData; }\n\n    var segn = pathData.length - 1;\n    var segi, segd, angle, radius, dx, dy;\n    var minRadius = .25;\n\n    segd = pathData[0];\n    if (segd == undefined) {\n      console.error(pathData);\n      throw new Error();\n    }\n    radius = minRadius + segd[pdi_density] * radiusFactor;\n    angle = segd[pdi_angle] + Math.PI * .5;\n    dx = Math.sin(angle) * radius;\n    dy = -Math.cos(angle) * radius;\n    lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n    lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n\n    for (segi = 1; segi < segn; segi++) {\n      segd = pathData[segi];\n      angle = (pathData[segi - 1][pdi_angle] + segd[pdi_angle] + Math.PI) * .5;\n      radius = minRadius + segd[pdi_density] * radiusFactor;\n      dx = Math.sin(angle) * radius;\n      dy = -Math.cos(angle) * radius;\n      lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n      lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n    }\n\n    segd = pathData[segn];\n    radius = minRadius + segd[pdi_density] * radiusFactor;\n    angle = segd[pdi_angle] + Math.PI * .5;\n    dx = Math.sin(angle) * radius;\n    dy = -Math.cos(angle) * radius;\n    lineData.push([segd[pdi_x] + dx, segd[pdi_y] + dy]);\n    lineData.unshift([segd[pdi_x] - dx, segd[pdi_y] - dy]);\n\n    return lineData;\n  };\n\n  return timamp;\n\n})();","/**\n * Created by wouter on 22/09/2015.\n */\n\n/**\n * eu15a case study constructor.\n */\nvar eu15a = function () {\n\n  var caseStudy = enram.caseStudy(\"eu15a\", JsonDataService());\n\n  caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n    return d3.geo.mercator()\n      .scale(caseStudy.mapScaleFactor * mapWidth)\n      .translate([mapWidth / 2, mapHeight / 2])\n      .center(caseStudy.mapCenter);\n  };\n\n  return caseStudy;\n}();\n","/**\n * Created by wouter on 22/09/2015.\n */\n\n/**\n * us15a case study constructor.\n */\nvar us15a = function () {\n\n  var caseStudy = enram.caseStudy(\"us15a\", JsonDataService());\n\n  caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n    return d3.geo.mercator()\n      .scale(caseStudy.mapScaleFactor * mapWidth)\n      .translate([mapWidth / 2, mapHeight / 2])\n      .center(caseStudy.mapCenter);\n  };\n\n  return caseStudy;\n}();\n"],"sourceRoot":"/source/"}