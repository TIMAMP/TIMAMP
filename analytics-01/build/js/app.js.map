{"version":3,"sources":["utils.js","expose.js","enram.js","app.js","timamp.js","expose/density-plot.js","expose/exposeView.js","expose/line-chart.js","us15a/us15a-raw.js","us15a/us15a-segmented.js","eu15a/init.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/**\n * Created by wouter on 13/12/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('utils', [])\n    .factory('utils', [utils]);\n\n  /**\n   * utils service constructor.\n   *\n   * @returns The service object.\n   */\n  function utils() {\n    //console.log(\">> utils factory constructor\");\n\n    var utils = {};\n\n\n    /**\n     * Identity function, simply returns the first argument.\n     * @param {*} d\n     * @returns {*}\n     */\n    utils.id = function (d) { return d; }\n\n// #############################################################################\n// Geometric functions\n// -----------------------------------------------------------------------------\n\n    utils.geo = {};\n\n    /** @const */\n    utils.geo._GEO_DIST_FACTOR = 360 / (6371 * 2 * Math.PI);\n\n    /**\n     * Returns the angle (in degrees) corresponding with the given displacement in km.\n     * The angle (in degrees) of a displacement of 1 km horizontally along the equator:\n     * 1 km = 1 / (2 * 6371 * pi) * 360 degrees = 0.008993216059 degrees.\n     * Inversely: 1 degree ~= 111.19492664 km\n     *\n     * @param {Number} dist The distance in km.\n     * @returns {number}\n     */\n    utils.geo.distAngle = function (dist) {\n      return dist * utils.geo._GEO_DIST_FACTOR;\n    };\n\n    /**\n     * Returns the destination location, given a start location, a bearing and a\n     * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n     * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n     * @param  {number}        bearing in degrees clockwise from north\n     * @param  {number}        distance in km\n     * @return {Array<number>} a [lon, lat] coordinate in degrees\n     */\n    utils.geo.destination = function (start, bearing, distance) {\n      var dR = distance / 6371;  // angular distance = distance / earth’s radius\n      var lat1 = utils.radians(start[1]);\n      var lon1 = utils.radians(start[0]);\n      bearing = utils.radians(bearing);\n      var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n        Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n      var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n          Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n      lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n      //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n      return [utils.degrees(lon2), utils.degrees(lat2)];\n    };\n\n    /**\n     * Returns the destination location, given a start location, a bearing and a\n     * distance. Based on http://www.movable-type.co.uk/scripts/latlong.html\n     * @param  {Array<number>} start a [lon, lat] coordinate in degrees\n     * @param  {number}        bearing in radians clockwise from north\n     * @param  {number}        distance in km\n     * @return {Array<number>} a [lon, lat] coordinate in degrees\n     */\n    utils.geo.destinationRad = function (start, bearing, distance) {\n      var dR = distance / 6371;  // angular distance = distance / earth’s radius\n      var lat1 = utils.radians(start[1]);\n      var lon1 = utils.radians(start[0]);\n      var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dR) +\n        Math.cos(lat1) * Math.sin(dR) * Math.cos(bearing));\n      var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(lat1),\n          Math.cos(dR) - Math.sin(lat1) * Math.sin(lat2));\n      lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n      //console.log(start, [Math.degrees(lon2), Math.degrees(lat2)]);\n      return [utils.degrees(lon2), utils.degrees(lat2)];\n    };\n\n// #############################################################################\n// Interpolation\n// -----------------------------------------------------------------------------\n\n    utils.idw = function (x, y, tValues, xValues, yValues, power) {\n      if (tValues.length != xValues.length) {\n        throw \"tValues.length != xValues.length\";\n      }\n      if (xValues.length != yValues.length) {\n        throw \"xValues.length != yValues.length\";\n      }\n      var len = tValues.length, i, dx, dy, wi, ws = 0, r = 0;\n      for (i = 0; i < len; i++) {\n        dx = x - xValues[i];\n        dy = y - yValues[i];\n        if (dx == 0 && dy == 0) { return tValues[i]; }\n        wi = 1 / Math.pow(Math.sqrt(dx * dx + dy * dy), power);\n        r += wi * tValues[i];\n        ws += wi;\n      }\n      return r / ws;\n    };\n\n// #############################################################################\n// Color functions\n// -----------------------------------------------------------------------------\n\n    /**\n     * Transforms HSB to RGB color. Accepts either 3 arguments (hue, saturaion and\n     * value/brightness in  the range [0, 1]), or 1 argument (an object with h, s\n     * and v properties in the range [0, 1]).\n     * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n     * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * @param   {Number|Object} h The hue value in the range [0, 1], or an\n     *                            object with three properties {h:h, s:s, v:v}.\n     * @param   {Number}        s The saturation in the range [0, 1].\n     * @param   {Number}        v The value/brightness in the range [0, 1].\n     * @returns {Object}        An object with r, g and b properties in the range\n     *                          [0, 255].\n     */\n    utils.hsvToRgb = function (h, s, v) {\n      var r, g, b, i, f, p, q, t;\n      if (h && s === undefined && v === undefined) {\n        s = h.s, v = h.v, h = h.h;\n      }\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0: r = v, g = t, b = p; break;\n        case 1: r = q, g = v, b = p; break;\n        case 2: r = p, g = v, b = t; break;\n        case 3: r = p, g = q, b = v; break;\n        case 4: r = t, g = p, b = v; break;\n        case 5: r = v, g = p, b = q; break;\n      }\n      return {\n        r: Math.floor(r * 255),\n        g: Math.floor(g * 255),\n        b: Math.floor(b * 255)\n      };\n    };\n\n    /**\n     * Converts an RGB color value to HSL.\n     * Assumes r, g, and b are contained in the set [0, 255] and\n     * returns h, s, and l in the set [0, 1].\n     * Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c.\n     * Conversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * @param   {Number|Object} r The red color value in the range [0, 255], or an\n     *                            object with three properties {r:r, g:g, b:b}.\n     * @param   {Number}        g The green color value in the range [0, 255].\n     * @param   {Number}        b The blue color value in the range [0, 255].\n     * @returns {Array}         An object with h, a and v properties in the range\n     *                          [0, 1].\n     */\n    utils.rgbToHsv = function (r, g, b) {\n      var min, max, h, s, v, d;\n      if (r && g === undefined && b === undefined) {\n        g = r.g, b = r.b, r = r.r;\n      }\n      r = r / 255, g = g / 255, b = b / 255;\n      max = Math.max(r, g, b), min = Math.min(r, g, b);\n      v = max;\n      d = max - min;\n      s = max === 0 ? 0 : d / max;\n      if (max == min) {\n        h = 0; // achromatic\n      } else {\n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n      return {h:h, s:s, v:v};\n    };\n\n    /**\n     * Transform the given r, g and b values in the range [0, 255] to its\n     * hex-representation.\n     * @param   {Number|Object} r The red color value in the range [0, 255], or an\n     *                            object with three properties {r:r, g:g, b:b}.\n     * @param   {Number}        g The green color value in the range [0, 255].\n     * @param   {Number}        b The blue color value in the range [0, 255].\n     * @returns {String}        The hex represenation of the rgb value.\n     */\n    utils.rgbToHex = function (r, g, b) {\n      if (r && g === undefined && b === undefined) {\n        g = r.g, b = r.b, r = r.r;\n      }\n      r = r.toString(16);\n      if (r.length == 1) r = \"0\" + r;\n      g = g.toString(16);\n      if (g.length == 1) g = \"0\" + g;\n      b = b.toString(16);\n      if (b.length == 1) b = \"0\" + b;\n      return \"#\" + r + g + b;\n    };\n\n    utils.hsvToHex = function (h, s, v) {\n      return utils.rgbToHex(utils.hsvToRgb(h, s, v));\n    };\n\n    utils.hsvaToRgba = function (h, s, v, a) {\n      var rgb = utils.hsvToRgb(h, s, v);\n      return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + a + \")\";\n    };\n\n// #############################################################################\n// Statistics\n// -----------------------------------------------------------------------------\n\n    /**\n     * Returns the average of the values in the given array.\n     * @param   {Array}            ary     An array with numbers.\n     * @param   {*}                undefAv The return value when the array is empty.\n     * @returns {Number|undefined} The average or undefined if the array is empty.\n     */\n    utils.average = function (ary, undefAv) {\n      if (arguments.length === 1) { undefAv = 0; }\n      if (ary === undefined) { return undefAv; }\n      var len = ary.length;\n      if (len === 0) { return undefAv;  }\n      var r = 0;\n      for (var i = 0; i < len; i++) { r += ary[i]; }\n      return r / len;\n    };\n\n    /**\n     * Returns the average of a list of displacements, given as an array of\n     * directions and an array of corresponding speeds. These array should have\n     * the same length.\n     * @param   {Array}            angles List of angles in radias.\n     * @param   {Array}            speeds List of speeds.\n     * @param   {*}                undefAv The return value when the array is empty.\n     * @returns {Object|undefined} An object with angle and speed properties or\n     *                             undefined if the given arrays are empty.\n     */\n    utils.averageDisplacement = function (angles, speeds, undefAv) {\n      if (angles === undefined || speeds === undefined) { return undefAv; }\n      var len = angles.length;\n      if (len === 0) { return undefAv; }\n      var x = 0, y = 0;\n      for (var i = 0; i < len; i++) {\n        x += Math.cos(angles[i]) * speeds[i];\n        y += Math.sin(angles[i]) * speeds[i];\n      }\n      x /= len;\n      y /= len;\n      return {\n        angle: Math.atan2(x, y),\n        speed: Math.sqrt(x * x + y * y)\n      };\n    };\n\n// #############################################################################\n// Math utilities\n// -----------------------------------------------------------------------------\n\n    /**\n     * Returns the given angle in degrees expressed as radians.\n     * @param   {Number} degrees The given angle in degrees.\n     * @returns {Number} The given angle in radians.\n     */\n    utils.radians = function (degrees) {\n      return degrees * Math.PI / 180;\n    };\n\n    /**\n     * Returns the given angle in radians expressed as degrees.\n     * @param   {Number} radians The given angle in radians.\n     * @returns {Number} The given angle in degrees.\n     */\n    utils.degrees = function (radians) {\n      return radians / Math.PI * 180;\n    };\n\n    /**\n     * Maps the value v from the source range [a, b] to the target range [c, d].\n     * @param   {Number} value The value to map.\n     * @param   {Number} low1 The first bound of the source range.\n     * @param   {Number} high1 The second bound of the source range.\n     * @param   {Number} low2 The first bound of the target range.\n     * @param   {Number} high2 The second bound of the target range.\n     * @returns {Number} The mapped value.\n     */\n    utils.mapRange = function (value, low1, high1, low2, high2) {\n      return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n    };\n\n    /**\n     * Constrains the given value v to the range [min, max]\n     * @param   {Number} v   The value to constrain.\n     * @param   {Number} min The minimum value of the range.\n     * @param   {Number} max The maximum value of the range.\n     * @returns {Number} The constrained value.\n     */\n    utils.constrain = function (v, min, max) {\n      if (v < min) return min;\n      else if (v > max) return max;\n      else return v;\n    };\n\n    /**\n     * Calculates the length of the vector (dx, dy).\n     * @param   {Number} dx [[Description]]\n     * @param   {Number} dy [[Description]]\n     * @returns {Number} [[Description]]\n     */\n    utils.vectorLength = function (dx, dy) {\n      return Math.sqrt(dx * dx + dy * dy);\n    };\n\n// #############################################################################\n// Support functions\n// -----------------------------------------------------------------------------\n\n    /**\n     * Return the size of one em in pixels.\n     * @returns {Number} The size of one em in pixels.\n     */\n    utils.emSize = function () {\n      return parseFloat($(\"body\").css(\"font-size\"));\n    };\n\n    /**\n     * Creates a list with n zeros.\n     * @param   {Number}   length The number of zeros to\n     * @returns {[[Type]]} [[Description]]\n     */\n    utils.zeroArray = function (length) {\n      var result = [];\n      for (var i = 0; i < length; i++) {\n        result.push(0);\n      }\n      return result;\n    };\n\n// -----------------------------------------------------------------------------\n\n    utils.debug = function (name, value) {\n      //$(\"#debug\").append(\"<p>\" + name + \": \" + value + \"</p>\");\n      if (name && value === undefined) {\n        console.log(name);\n      }\n      else {\n        console.log(name + \": \" + value);\n      }\n    };\n\n    return utils;\n  }\n\n})();\n","/**\n * Created by wouter on 17/12/2015.\n */\n\n/**\n * Created by wouter on 08/11/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('expose', [])\n    .factory('expose', [expose]);\n\n  /**\n   * Expose service constructor.\n   */\n  function expose() {\n    var expose = {};\n\n    /**\n     * Creates a set of matching colors as hex strings.\n     *\n     * The colors are generated using the HUSL color model, see\n     * http://www.husl-colors.org for more details.\n     *\n     * @param count the number of colors\n     * @param hueMin a number between 0 and 360\n     * @param hueMax a number between 0 and 360\n     * @param saturation a number between 0 and 100\n     * @param lightness a number between 0 and 100\n     * @returns {Array}\n     */\n    expose.getColorHexSet = function (count, hueMin, hueMax, saturation, lightness) {\n      if (count == 1) {\n        return [HUSL.toHex(hueMin, saturation, lightness)];\n      }\n      else {\n        var hueInc = (hueMax - hueMin) / (count - 1);\n        var colors = [];\n        for (var i = 0; i < count; i++) {\n          colors.push(HUSL.toHex(hueMin + i * hueInc, saturation, lightness));\n        }\n        return colors;\n      }\n    };\n\n    return expose;\n  }\n\n})();","/**\n * Created by wouter on 01/09/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('enram', [])\n    .factory('enram', [enram]);\n\n  /**\n   * Enram service constructor.\n   * @returns The service object.\n   */\n  function enram() {\n    //console.log(\">> enram service constructor\");\n    var enram = {};\n\n    /**\n     * Creates and returns a focus object.\n     * @param from      {moment}  the start of the focus window\n     * @param duration  {number}  the focus duration in hours\n     */\n    enram.focus = function (from, duration) {\n      var focus = {\n        from: from,\n        till: moment.utc(from).add(duration, 'hours'),\n        duration: duration,\n        isFocus: true\n      };\n\n      /**\n       * Update the from moment and the matching till moment.\n       * @param from {moment}\n       */\n      focus.setFrom = function (from) {\n        this.from = from;\n        this.till = moment(from).add(this.duration, 'hours');\n      };\n\n      /**\n       * Update the till moment and the matching from moment.\n       * @param till {moment}\n       */\n      focus.setTill = function (till) {\n        this.till = till;\n        this.from = moment(till).subtract(focus.duration, 'hours');\n      };\n\n      /**\n       * @return the number of\n       */\n      focus.segmentCount = function (caseStudy) {\n        return this.duration * 60 / caseStudy.segmentSize;\n      };\n\n      return focus;\n    };\n\n    /**\n     * caseStudy form:\n     * {\n     *   <see properties in README.md>\n     *   defaultFocusFrom: {moment}\n     *   segmentCount: {number} The number of segments in the source data\n     * }\n     *\n     * @param basePath {string}\n     * @param dataService {object}\n     * @returns The caseStudy object.\n     */\n    enram.caseStudy = function (basePath, dataService) {\n      var caseStudy = {\n        basePath: basePath,\n        dataService: dataService,\n        isCaseStudy: true\n      };\n\n      /**\n       * Asynchronously loads the case study metadata and other necessary data.\n       * @param handler\n       */\n      caseStudy.load = function (handler) {\n        this._loadMetaData(function () {\n          caseStudy.dataService.initialize(caseStudy, function () {\n            console.info(\"Loaded case study\", caseStudy.label);\n            handler();\n          });\n        });\n      };\n\n      /**\n       * Load case study data from properly formatted json file.\n       * @param {function(enram.caseStudy)} handler  This handler is\n       *   called with the caseStudy as argument.\n       */\n      caseStudy._loadMetaData = function (handler) {\n        //console.log(this);\n        caseStudy.urlBase = \"data/\" + this.basePath + \"/\";\n        d3.json(caseStudy.urlBase + \"metadata.json\", function (error, json) {\n          //console.log(caseStudy);\n          if (error) {\n            throw error;\n            //throw new Error(\"Error in caseStudy._loadMetaData. \"\n            //    + JSON.parse(error.responseText).error.join(\"; \"));\n          }\n          else {\n            for (var attr in json) {\n              if (json.hasOwnProperty(attr)) caseStudy[attr] = json[attr];\n            }\n            caseStudy.dataFrom = moment.utc(caseStudy.dataFrom);\n            caseStudy.dataTill = moment.utc(caseStudy.dataTill);\n            caseStudy.defaultFocusFrom = moment.utc(caseStudy.focusFrom);\n\n            // Create mapping from radar ids to indices:\n            caseStudy.radarIndices = {};\n            caseStudy.radLons = [];\n            caseStudy.radLats = [];\n            caseStudy.radars.forEach(function (radar, i) {\n              radar.location = [radar.longitude, radar.latitude];\n              caseStudy.radarIndices[radar.id] = i;\n              caseStudy.radLons.push(radar.longitude);\n              caseStudy.radLats.push(radar.latitude);\n            });\n\n            caseStudy.topoJsonUrl = caseStudy.urlBase + \"topo.json\";\n            caseStudy.selectedRadar = caseStudy.radars[0];\n            caseStudy.radarCount = caseStudy.radars.length;\n\n            var dms = caseStudy.dataTill.valueOf() - caseStudy.dataFrom.valueOf();\n           caseStudy.segmentCount = dms / 1000 / 60 / caseStudy.segmentSize;\n            if (Math.abs(caseStudy.segmentCount) != caseStudy.segmentCount) {\n              console.error(caseStudy.dataFrom.valueOf());\n              console.error(caseStudy.dataTill.valueOf());\n              throw new Error(\"Expected integer segmentCount, got: \" +\n                caseStudy.segmentCount + \", dms: \" + dms);\n            }\n\n            handler(caseStudy);\n          }\n        });\n      };\n\n      /**\n       * Loads the data for the given focus.\n       * @param focus    {enram.focus}\n       * @param handler  {function(dataObject)}  called when the data is loaded\n       */\n      caseStudy.loadFocusData = function (focus, handler) {\n        //console.log(\">> caseStudy.loadFocusData()\");\n        this.dataService.loadFocusData(caseStudy, focus, handler);\n      };\n\n      /**\n       * @return the segment duration in milliseconds\n       */\n      caseStudy.segmentMillis = function () {\n        return this.segmentSize * 60 * 1000;\n      };\n\n      caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n        console.error(\"There is no implementation for getProjection in case study '\"\n          + caseStudy.label + \"'.\");\n      };\n\n      return caseStudy;\n    };\n\n    /**\n     * Loads the case studies passed as arguments and calls the handlers when complete.\n     */\n    enram.loadCaseStudies = function (caseStudies, handler) {\n      //console.log(\"enram.initializeCaseStudies()\");\n\n      // the index of the next case study to load\n      var current = 0;\n\n      // recursively load the next case study:\n      function next() {\n        //console.log(\" > next \", caseStudies.length, current);\n        if (current == caseStudies.length) {\n          // all case studies\n          handler(caseStudies);\n        }\n        else {\n          caseStudies[current].load(function () {\n            current++;\n            next();\n          });\n        }\n      }\n\n      // start loading the first case study:\n      next();\n    };\n\n    return enram;\n  }\n\n})();\n","(function() {\n  'use strict';\n\n  //console.log(\"loading exposeApp module\");\n\n  var app = angular.module('exposeApp', [\n    // Angular libraries:\n    'ngAnimate',\n    //'ngTouch',\n    'ui.bootstrap',\n    'ui.router',\n\n    // app partials:\n    'expose',\n    'enram'\n  ]);\n\n  /**\n   * Configures the app.\n   */\n  app.config(['$urlRouterProvider', '$locationProvider', '$httpProvider',\n    function ($urlRouterProvider, $locationProvider, $httpProvider) {\n      //console.log(\">> app.config\");\n      $urlRouterProvider.otherwise('/');\n\n      $locationProvider.html5Mode({\n        enabled: false,\n        requireBase: false\n      });\n\n      $locationProvider.hashPrefix('!');\n\n      FastClick.attach(document.body);\n\n      delete $httpProvider.defaults.headers.common['X-Requested-With'];\n    }]);\n\n  /**\n   * Start the application.\n   */\n  app.run(function () {\n    //console.log(\">> app.run\");\n  });\n\n  /**\n   * Settings provider.\n   */\n  app.factory('settings', ['$log', function ($log) {\n    var settings = {};\n\n    // True when the browser supports svg.\n    settings.svgSupported = document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\");\n\n    // True when interface animations are enabled.\n    settings.animationsEnabled = false;\n\n    // The duration in hours of the focus interval.\n    settings.focusDuration = 24;\n\n    // The number of radar-graphs on one page.\n    settings.radarsPerPage = 5;\n\n    return settings;\n  }]);\n\n  /**\n   * Main app controller.\n   */\n  app.controller('appCtrl', ['$scope', 'settings', 'enram', '$injector', '$uibModal', '$q', '$log',\n    function ($scope, settings, enram, $injector, $uibModal, $q, $log) {\n      //console.log(\">> app.appCtrl constructor\");\n      //console.log(us15a);\n\n      /**\n       * Show 'LOADING' while loading something and returns a promise that is resolved\n       * when the loading is complete.\n       *\n       * @param loader  A function that performs the loading and that takes a\n       *                function as sole argument. This function is called when the\n       *                loading is complete.\n       */\n      $scope.load = (function () {\n        var counter = 0; // tracks overlapping calls\n        return function (loader) {\n          counter++;\n          if (counter == 1) {\n            // TODO: show 'LOADING' if this is not yet the case\n          }\n          return $q(function (resolve, reject) {\n            loader(\n              /* resolve handler */\n              function () {\n                resolve.apply(this, arguments);\n                counter--;\n                if (counter == 0) {\n                  // TODO: stop show 'LOADING'\n                }\n              },\n              /* reject handler */\n              function () {\n                reject.apply(this, arguments);\n                counter--;\n                if (counter == 0) {\n                  // TODO: stop show 'LOADING'\n                }\n              });\n          });\n        }\n      })();\n\n      /** Returns the current focus. */\n      function currentFocus() {\n        return enram.focus($scope.model.dayOption.moment, settings.focusDuration);\n      }\n\n      /**\n       * Helper function that load the data for the current focus in the current case study.\n       *\n       * <p>This function is typically called as follows:</p>\n       *\n       * <code>loadFocusData().then(function(data) { <handle data> });</code>\n       *\n       * @return  {promise}\n       */\n      function loadFocusData() {\n        return $scope.load(function (resolve, reject) {\n          $scope.model.caseStudy.loadFocusData(currentFocus(), function (data) {\n            $scope.model.focusData = data;\n            resolve(data);\n          });\n        });\n      }\n\n      /**\n       * Sets the currently selected caseStudy.\n       *\n       * @param caseStudy\n       */\n      $scope.setCaseStudy = function (caseStudy) {\n        if ($scope.model.caseStudy == caseStudy) { return; }\n        //$log.info(\"Selected caseStudy:\", caseStudy);\n        $scope.model.caseStudy = caseStudy;\n\n        // update the day options:\n        $scope.model.dayOptions = [];\n        var mom = moment(caseStudy.dataFrom).hours(0).minutes(0);\n        while (mom.isBefore(caseStudy.dataTill)) {\n          $scope.model.dayOptions.push({\n            moment: mom,\n            label: mom.format(\"MMM D, 'YY\")\n          });\n          mom = moment(mom).add(24, \"hours\");\n        }\n        $scope.model.dayOption = $scope.model.dayOptions[3];\n\n        // Update the radio options:\n        $scope.model.radarOptions = [];\n        var radarCnt = caseStudy.radars.length;\n        var radarOption;\n        caseStudy.radars.forEach(function (radar, i) {\n          if (i % settings.radarsPerPage == 0) {\n            var till = Math.min(i + settings.radarsPerPage, radarCnt);\n            radarOption = {\n              from: i,\n              till: till,\n              label: \"Radars \" + (i + 1) + \"-\" + till\n            };\n            $scope.model.radarOptions.push(radarOption);\n          }\n        });\n        $scope.model.radarOption = $scope.model.radarOptions[0];\n\n        // load the data:\n        loadFocusData().then(function(data) {\n          $scope.$broadcast('redrawExpose');\n        });\n      };\n\n      /**\n       * Sets the currently selected dayOption.\n       *\n       * @param dayOption\n       */\n      $scope.setDayOption = function (dayOption) {\n        if ($scope.model.dayOption == dayOption) { return; }\n        //$log.info(\"Selected dayOption:\", dayOption);\n        $scope.model.dayOption = dayOption;\n\n        // load the data:\n        loadFocusData().then(function(data) {\n          $scope.$broadcast('redrawExpose');\n        });\n      };\n\n      /**\n       * Sets the currently selected radarOption.\n       *\n       * @param radarOption\n       */\n      $scope.setRadarOption = function (radarOption) {\n        if ($scope.model.radarOption == radarOption) { return; }\n        //$log.info(\"Selected radarOption:\", radarOption);\n        $scope.model.radarOption = radarOption;\n\n        // load the data:\n        loadFocusData().then(function(data) {\n          $scope.$broadcast('redrawExpose');\n        });\n      };\n\n      /**\n       * Disable/Enable application-wide animations.\n       */\n      $scope.toggleAnimation = function () {\n        $scope.settings.animationsEnabled = !$scope.settings.animationsEnabled;\n        $animate.enabled($scope.settings.animationsEnabled);\n      };\n\n      /**\n       * Opens a modal window with an error message.\n       *\n       * @param title The title to show in the window.\n       * @param message The message to show in the window.\n       * @param fatal True when the error is fatal.\n       */\n      $scope.reportError = function (title, message, fatal) {\n        //console.log(\">> appCtrl.reportError()\");\n\n        var modalScope = $scope.$new();\n        modalScope.title = title;\n        modalScope.message = message;\n        modalScope.showOK = !fatal;\n        modalScope.showCancel = false;\n\n        return $uibModal.open({\n          scope: modalScope,\n          templateUrl: \"modalErrorContent.html\",\n          animation: settings.animationsEnabled,\n          keyboard: false,\n          backdrop: 'static'\n        });\n      };\n\n      // The settings are made available in the scope.\n      $scope.settings = settings;\n\n      /**\n       * The main model object.\n       *\n       * We're using a model object to avoid scope inheritance problems due to\n       * the fact that ng-model directives in a child-scope can create shadowing\n       * properties hiding the actual properties in this scope.\n       *\n       * Model properties:\n       * - caseStudies :  The potential case studies.\n       * - caseStudy :    The currently selected case study.\n       * - radarOptions : The potential radar-sets to show.\n       * - radarOption :  The currently selected radar set.\n       * - dayOptions :   The potential days to select.\n       * - dayOption :    The currently selected day.\n       * - focusData :    The currently shown focus data.\n       */\n      $scope.model = {\n        caseStudies: [],\n        caseStudy: null,\n        radarOptions: [],\n        radarOption: null,\n        dayOptions: [],\n        dayOption: null,\n        focusData: null\n      };\n\n      // load the case studies:\n      $scope.load(function (resolve, reject) {\n        var caseStudies = [\n          $injector.get('us15a.segmented'),\n          $injector.get('us15a.raw')\n        ];\n        enram.loadCaseStudies(caseStudies, resolve);\n      }).then(function (caseStudies) {\n        //console.log(\"Initialised the case studies\", caseStudies);\n        $scope.model.caseStudies = caseStudies;\n        $scope.setCaseStudy(caseStudies[0]);\n      });\n\n      // Assert that SVG is supported by the browser:\n      if (!settings.svgSupported) {\n        var msg = \"SVG is not supported in this browser. Please use a recent browser.\";\n        $log.error(msg);\n        $scope.reportError(\"Unsupported Browser\", msg, true);\n      }\n\n    }]);\n\n  /**\n   * Navbar controller.\n   */\n  app.controller('navBarCtrl', ['$scope', function ($scope) {\n    //console.log(\">> app.navBarCtrl constructor\");\n\n    /**\n     * True when the navbar is collapsed.\n     * @type {boolean}\n     */\n    $scope.isCollapsed = true;\n\n    /**\n     * Sets the caseStudy in the appCtrl's scope and collapsed the navbar.\n     * @param caseStudy\n     */\n    $scope.caseStudySelected = function (caseStudy) {\n      $scope.setCaseStudy(caseStudy);\n      $scope.isCollapsed = true;\n    };\n\n    /**\n     * Sets the dayOption in the appCtrl's scope and collapsed the navbar.\n     * @param dayOption\n     */\n    $scope.dayOptionSelected = function (dayOption) {\n      $scope.setDayOption(dayOption);\n      $scope.isCollapsed = true;\n    };\n\n    /**\n     * Sets the radarOption in the appCtrl's scope and collapsed the navbar.\n     * @param radarOption\n     */\n    $scope.radarOptionSelected = function (radarOption) {\n      $scope.setRadarOption(radarOption);\n      $scope.isCollapsed = true;\n    };\n\n  }]);\n\n})();\n","/**\n * Created by wouter on 17/12/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('timamp', ['utils'])\n    .factory('timamp', ['utils', timamp]);\n\n  function timamp() {\n    //console.log(\">> timamp service constructor\");\n    var timamp = {};\n\n    /**\n     * The timamp data structure is constructed such that it efficiently facilitates\n     * the interpolation operations needed when constructing the paths in the timamp\n     * visualization.\n     *\n     * Terminology:\n     * - segment : The data is temporally segmented in segments of e.g. 20 minutes.\n     * - focus : A temporal section of the data currently shown in the visualisation.\n     * - strata : An altitude range.\n     *\n     * This data structure should always be complete, meaning that for each segment in the\n     * focus window, for each strata and for each radar, there should be a value, even\n     * if the original data does not fully cover the given focus window.\n     *\n     * The data object has the following form:\n     * {\n     *   caseStudy: {enram.caseStudy},  // the caseStudy\n     *   focus: {enram.focus},    // specifies the focus start and duration\n     *   segmentCount: {number},  // the number of segments in the focus\n     *   densities: {Array},      // matrix with dimensions: [segment, strata, radar]\n     *   uSpeeds: {Array},        // matrix with dimensions: [segment, strata, radar]\n     *   vSpeeds: {Array},        // matrix with dimensions: [segment, strata, radar]\n     *   speeds: {Array},         // matrix with dimensions: [segment, strata, radar]\n     *   avDensities: {Array},    // matrix with dimensions: [strata, radar]\n     * }\n     *\n     * @param caseStudy  {enram.caseStudy}\n     * @param focus      {enram.focus}\n     * @returns the data structure\n     */\n    timamp.dataObject = function (caseStudy, focus) {\n      var dataObject = {\n        caseStudy: caseStudy,\n        focus: focus,\n        segmentCount: focus.segmentCount(caseStudy),\n        densities: [],\n        uSpeeds: [],\n        vSpeeds: [],\n        speeds: [],\n        avDensities: []\n      };\n\n      /**\n       * Initializes the data structure to be filled with actual data.\n       *\n       * @return the data object\n       */\n      dataObject.initStructure = function () {\n        var segn = this.segmentCount;\n        var strn = caseStudy.strataCount;\n        var radn = caseStudy.radarCount;\n        for (var segi = 0; segi < segn; segi++) {\n          var densities = [];\n          var uSpeeds = [];\n          var vSpeeds = [];\n          var speeds = [];\n          for (var stri = 0; stri < strn; stri++) {\n            densities.push(utils.zeroArray(radn));\n            uSpeeds.push(utils.zeroArray(radn));\n            vSpeeds.push(utils.zeroArray(radn));\n            speeds.push(utils.zeroArray(radn));\n          }\n          this.densities.push(densities);\n          this.uSpeeds.push(uSpeeds);\n          this.vSpeeds.push(vSpeeds);\n          this.speeds.push(speeds);\n        }\n\n        for (stri = 0; stri < strn; stri++) {\n          this.avDensities.push(utils.zeroArray(radn));\n        }\n\n        return this;\n      };\n\n      // empty partial data structure to use in dataObject.addMissingSegments:\n      var missingSegmentData = [];\n      var strn = caseStudy.strataCount;\n      var radn = caseStudy.radarCount;\n      for (var stri = 0; stri < strn; stri++) {\n        missingSegmentData.push(utils.zeroArray(radn));\n      }\n\n      /**\n       * Prepends data entries to replace missing data for a given amount of segments.\n       * @param amount The number of segments for which to add data entries.\n       */\n      dataObject.prependMissingSegments = function (amount) {\n        for (var i = 0; i < amount; i++) {\n          this.densities.unshift(missingSegmentData);\n          this.uSpeeds.unshift(missingSegmentData);\n          this.vSpeeds.unshift(missingSegmentData);\n          this.speeds.unshift(missingSegmentData);\n        }\n      };\n\n      /**\n       * Appends data entries to replace missing data for a given amount of segments.\n       * @param amount The number of segments for which to add data entries.\n       */\n      dataObject.appendMissingSegments = function (amount) {\n        for (var i = 0; i < amount; i++) {\n          this.densities.push(missingSegmentData);\n          this.uSpeeds.push(missingSegmentData);\n          this.vSpeeds.push(missingSegmentData);\n          this.speeds.push(missingSegmentData);\n        }\n      };\n\n      return dataObject;\n    };\n\n    return timamp;\n  }\n\n})();\n","/**\n * Created by wouter on 01/09/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('expose')\n    .factory('expose.densityPlot', ['settings', 'expose', 'expose.lineChart', densityPlot]);\n\n  /**\n   * demoPainter service constructor.\n   *\n   * A pointer service is used by the exposeView directive\n   * for adding and updating the actual content in the exposeView.\n   *\n   * This sample service adds an svg element and draw in it a set of diagonal\n   * dashed lines, making use of D3.\n   *\n   * Each painter service should provide the following public functions:\n   * - init(scope, container)\n   * - draw(scope, viewRect, dirties)\n   * - clear()\n   */\n  function densityPlot(settings, expose, lineChart) {\n    var viewContainer = null;\n    var svg = null; // the svg element (as D3 reference)\n    var painter = {};\n\n    // Raw data indices:\n    var ri_radar_id = 0,\n      ri_interval_start_time = 1,\n      ri_altitude_band = 2,\n      ri_avg_u_speed = 3,\n      ri_avg_v_speed = 4,\n      ri_avg_bird_density = 5,\n      ri_vertical_integrated_density = 6,\n      ri_number_of_measurements = 7,\n      ri_speed = 8;\n\n    /**\n     * Called once by the exposeView directive when the view should be initialized.\n     *\n     * @param $scope The scope of the exposeView directive.\n     * @param viewContainer The html element in which to add the content.\n     */\n    painter.init = function ($scope, el) {\n      viewContainer = el;\n    };\n\n    /**\n     * This function is called by the exposeView directive when\n     * the view's content should be drawn or redrawn.\n     *\n     * @param $scope The scope of the exposeView directive.\n     * @param viewRect The rect that corresponds to the content bounding box\n     *                 in the container passed to the init function.\n     * @param dirties An object that may have the following properties:\n     *                - all = true when the content is drawn for the first time\n     *                - size = true when the view container was resized\n     *                An arbitrary dirties object can be passed when dispatching\n     *                a redrawExpose event to the exposeView directive. This object\n     *                is then passed to this function as this argument.\n     *                This parameter is guaranteed to be always be an object, even\n     *                when no custom dirties object is given and none of the system\n     *                properties apply.\n     */\n    painter.draw = function ($scope, viewRect, dirties) {\n      //console.log(\">> densityPlot.draw()\", dirties.all, dirties.size, $scope.ready);\n\n      // Only redraw when needed:\n      if (!(dirties.all || dirties.size)) { return; }\n      if ($scope.model.focusData == null) { return; }\n\n      // add svg element:\n      if (svg) { svg.remove(); } // remove the existing svg content\n      svg = d3.select(viewContainer).append(\"svg\")\n        .attr(\"width\", viewRect.width)\n        .attr(\"height\", viewRect.height);\n\n      // parameters:\n      var padLeft = 40;\n      var padRight = 25;\n      var padTop = 25;\n      var padBottom = 50;\n      var chartGap = 10; // the (vertical) gap between graphs in pixels\n      var chartPadTop = 20;\n      var subChartGap = 5; // the (vertical) gap between graphs in pixels\n\n      // altitudes:\n      var altitudes = [\n        { from: 200, till: 1600, label: \"200 - 1600 m\" },\n        { from: 1600, till: 3000, label: \"1600 - 3000 m\" }\n      ];\n      expose.getColorHexSet(altitudes.length, 110, 260, 100, 60).forEach(function (c, i) {\n        altitudes[i].color = c;\n      });\n\n      // derived variables:\n      var data = $scope.model.focusData;\n      var focus = data.focus;\n      var caseStudy = $scope.model.caseStudy;\n      var focusTime = focus.from.valueOf();\n      var focusMillis = focus.duration * 60 * 60 * 1000; // the focus duration in milliseconds\n\n      var radarOption = $scope.model.radarOption;\n      var radarFromIdx = radarOption.from; // the index of the first radar to graph\n      var radarTillIdx = radarOption.till; // the index of the last radar to graph\n\n      var contentWidth = viewRect.width - padLeft - padRight;\n      var contentHeight = viewRect.height - padTop - padBottom;\n      var rpp = settings.radarsPerPage;\n      var chartComboHeight = (contentHeight - (rpp - 1) * chartGap - rpp * chartPadTop)  / rpp;\n      var chartHeight = (chartComboHeight - subChartGap) / 2;\n\n      var strn = caseStudy.strataCount;\n      var radi, radar, i;\n\n      // X-axis spec:\n      var xGLValue = focus.start;\n      var xGLValues = [xGLValue];\n      var xLabels = [];\n      for (i = 0; i < focus.duration; i++) {\n        xGLValues.push(xGLValue);\n        xLabels.push({ value: xGLValue, label: i });\n        xGLValue = moment(xGLValue).add(1, \"hours\");\n      }\n      xLabels.push({ value: xGLValue, label: \"GMT\" });\n      var xAxisSpec_1 = {\n        range: { min: focusTime, max: focusTime + focusMillis },\n        gridLines: {\n          values: xGLValues\n        }\n      };\n      var xAxisSpec_2 = {\n        range: { min: focusTime, max: focusTime + focusMillis },\n        gridLines: {\n          values: xGLValues\n        },\n        labels: xLabels\n      };\n\n      // Y-axis specs:\n      var yAxisSpec_density = {\n        range: { min: 0, max: 400 },\n        gridLines: {\n          values: [ 200 ]\n        },\n        labels: [\n          { label: \"0\", value: 0 },\n          { label: \"200\", value: 200 },\n          { label: \"400\", value: 400 }\n        ]\n      };\n      var yAxisSpec_speed = {\n        range: { min: 0, max: 40 },\n        gridLines: {\n          values: [ 20 ]\n        },\n        labels: [\n          { label: \"0\", value: 0 },\n          { label: \"20\", value: 20 },\n          { label: \"40\", value: 40 }\n        ]\n      };\n\n      // add the charts group:\n      var chartsG = svg.append(\"g\")\n        .attr(\"id\", \"charts\")\n        .attr(\"transform\", \"translate(\" + padLeft + \",\" + padTop + \")\");\n\n      // main title:\n      chartsG.append(\"text\")\n        .attr(\"class\", \"charts-title\")\n        .attr(\"x\", contentWidth / 2)\n        .attr(\"y\", 0)\n        .text(\"Densities and speeds – \" + focus.from.format(\"MMM D, YYYY\"));\n\n      // the graphs group contains the graphs, one for each radar:\n      for (radi = radarFromIdx; radi < radarTillIdx; radi++) {\n        radar = caseStudy.radars[radi];\n        var localRadi = radi - radarFromIdx;\n\n        // add chart-combo group with a title:\n        var dy = chartPadTop + localRadi * (chartComboHeight + chartPadTop + chartGap);\n        var chartComboG = chartsG.append(\"g\")\n          .attr(\"transform\", \"translate(0,\" + dy + \")\");\n        chartComboG\n          .append(\"text\")\n          .attr(\"x\", 3)\n          .attr(\"y\", -3)\n          .text(\"Radar \" + radar.id)\n          .classed(\"chart-combo-title\", true);\n\n        // prepare data sets:\n        var densiDataSets = [];\n        var speedDataSets = [];\n        for (var stri = 0; stri < strn; stri++) {\n          var densiData = [];\n          var speedData = [];\n          var times = data.getTimes(stri, radi);\n          var densities = data.getDensities(stri, radi);\n          var speeds = data.getSpeeds(stri, radi);\n          var len = times.length;\n          for (var di = 0; di < len; di++) {\n            densiData.push({\n              x: times[di],\n              y: densities[di]\n            });\n            speedData.push({\n              x: times[di],\n              y: speeds[di]\n            });\n          }\n          densiDataSets.push({\n            data: densiData,\n            label: \"Density\",\n            class: \"density-plot-line\",\n            color: altitudes[stri].color\n          });\n          speedDataSets.push({\n            data: speedData,\n            label: \"Speed\",\n            class: \"speed-plot-line\",\n            color: altitudes[stri].color\n          });\n        }\n\n        // draw density chart:\n        var densiChartG = chartComboG.append(\"g\");\n        lineChart.draw({\n          root: densiChartG,\n          chartWidth: contentWidth,\n          chartHeight: chartHeight,\n          title: {\n            label: \"Density\"\n          },\n          xAxis: xAxisSpec_1,\n          yAxis: yAxisSpec_density,\n          dataSets: densiDataSets\n        });\n\n        // draw speed chart:\n        var speedChartG = chartComboG.append(\"g\")\n          .attr(\"transform\", \"translate(0,\" + (chartHeight + subChartGap) + \")\");\n        lineChart.draw({\n          root: speedChartG,\n          chartWidth: contentWidth,\n          chartHeight: chartHeight,\n          title: {\n            label: \"Speed\"\n          },\n          xAxis: xAxisSpec_2,\n          yAxis: yAxisSpec_speed,\n          dataSets: speedDataSets\n        });\n      }\n\n      // draw altitudes color legend:\n      var altn = altitudes.length;\n      var itemGap = 15;\n      var itemWidth = Math.min((contentWidth - (altn - 1) * itemGap) / altn, 100);\n      var itemHeight = 20;\n      var legendG = chartsG\n        .append(\"g\")\n        .classed(\"legend\", true)\n        .attr(\"transform\", \"translate(0,\" + (contentHeight + 5) + \")\");\n      altitudes.forEach(function (alt, alti) {\n        var tx = alti * (itemWidth + itemGap);\n        var itemG = legendG\n          .append(\"g\")\n          .classed(\"legend-item\", true)\n          .attr(\"transform\", \"translate(\" + tx + \", 0)\");\n        itemG.append(\"rect\")\n          .attr(\"x\", 0).attr(\"y\", 8)\n          .attr(\"width\", 12).attr(\"height\", 6)\n          .style(\"fill\", altitudes[alti].color)\n          .classed(\"legend-color-box\", true);\n        itemG\n          .append(\"text\")\n          .attr(\"x\", itemHeight)\n          .attr(\"y\", itemHeight / 2)\n          .text(altitudes[alti].label)\n          .classed(\"legend-label\", true);\n      });\n    };\n\n    /**\n     * Clear the content.\n     */\n    painter.clear = function () {\n      if (svg) { svg.remove(); }\n    };\n\n    return painter;\n  }\n\n})();\n","/**\n * Created by wouter on 08/11/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('expose')\n    .directive('exposeView', ['$window', 'expose.densityPlot', exposeView]);\n\n  /**\n   * <exposeView> directive.\n   *\n   * This directive manages a expose view. It depends on a painter service\n   * that initializes and maintains the actual content. The painter is told to\n   * redraw the content when the window is rescaled or when the redrawExpose event is\n   * dispatched to this directive.\n   *\n   * This directive listens for the following events:\n   * - redrawExpose - Triggers a redraw of the content by the painter.\n   *\n   */\n  function exposeView($window, painter) {\n    return {\n      restrict: 'A',  // restrict to attribute use\n\n      link: function ($scope, element, attrs) {\n        // True as long as the view was not yet drawn:\n        var firstDraw = true;\n\n        // Tells the painter to redraw the view. To be called when the window\n        // was resized, when the redrawExpose event was received, etc.\n        function draw(dirties) {\n          // The painter's draw function is guaranteed to be given an object:\n          if (dirties === undefined) dirties = {};\n\n          // When the content will be drawn for the first time, then first call\n          // the painter's init function, and then call the draw with all = true\n          // in the dirties object.\n          if (firstDraw) {\n            painter.init($scope, element[0])\n            dirties.all = true;\n            firstDraw = false;\n          }\n\n          var viewRect = element[0].getBoundingClientRect();\n\n          painter.draw($scope, viewRect, dirties);\n        }\n\n        // Call redraw when the window was resized, but wait a bit to avoid\n        // staggered content redrawing, and pass a dirty object with size = true:\n        var timer = 0;\n        angular.element($window).bind('resize', function () {\n          clearTimeout (timer);\n          timer = setTimeout(function () { draw({ size: true }); }, 250);\n        });\n\n        // Redraw on receiving the redrawExpose event.\n        // Trigger this event by calling $scope.$broadcast('redrawExpose');\n        $scope.$on('redrawExpose', function (event, dirties) {\n          if (dirties === undefined) dirties = { all: true };\n          //console.log(\"exposeView >> redrawExpose event\");\n          draw(dirties);\n        });\n\n        // Call draw for the first time when the html element is ready:\n        $scope.$watch('$viewContentLoaded', draw);\n      }\n    };\n  }\n\n})();","/**\n * Created by wouter on 17/12/2015.\n */\n\n(function() {\n  'use strict';\n\n  angular.module('expose')\n    .factory('expose.lineChart', [lineChart]);\n\n  function lineChart() {\n    var lineChart = {};\n\n    /**\n     * Draws a line chart based on the given specs object.\n     *\n     * The spec objects should/may contain the following properties:\n     *\n     * {\n     *   root: <D3 group element>, // in which the chart is drawn in top-left corner\n     *   backgroundClass: <string>, // the class name for the background rect\n     *   chartWidth: <number>,\n     *   chartHeight: <number>,\n     *   title: { // optional - TODO: add positioning\n     *     label: <string>\n     *   },\n     *   xAxis: {\n     *     range: {\n     *       min: <number>,\n     *       max <number>\n     *     },\n     *     gridLines: { // optional, may be array with multiple sub-specs\n     *       class: <string>, // optional, class name for group that contains lines\n     *       values: [ <number>, ... ] // positions of the vertical grid lines\n     *     },\n     *     labels: [ // optional\n     *       {\n     *         value: <number>,\n     *         label: <string>\n     *       }, ...\n     *     ]\n     *   },\n     *   yAxis: { ... }, // same as xAxis\n     *   dataSets: [\n     *     {\n     *       data: [\n     *         {\n     *           x: <number>,\n     *           y: <number>\n     *         }\n     *       ],\n     *       label: <string>, // optional\n     *       class: <string>, // optional\n     *       color: <string>  // optional, color as hex string\n     *     }, ...\n     *   ]\n     * }\n     */\n    lineChart.draw = function (spec) {\n      var axisG, gridLinesG, labelsG;\n      var chartG = spec.root;\n\n      // x-dimension:\n      var xVSize = spec.xAxis.range.max - spec.xAxis.range.min;\n      var xMin = spec.xAxis.range.min;\n      var xFactor = spec.chartWidth / xVSize;\n      function xMap(value) {\n        return (value - xMin) * xFactor;\n      }\n\n      // y-dimension:\n      var yVSize = spec.yAxis.range.max - spec.yAxis.range.min;\n      var yMin = spec.yAxis.range.min;\n      var yFactor = spec.chartHeight / yVSize;\n      function yMap(value) {\n        return spec.chartHeight - (value - yMin) * yFactor;\n      }\n\n      // background and frame:\n      chartG\n        .append(\"rect\")\n        .attr(\"class\", \"chart-bg\")\n        .attr(\"width\", spec.chartWidth)\n        .attr(\"height\", spec.chartHeight);\n\n      // x-axis:\n      axisG = chartG\n        .append(\"g\")\n        .attr(\"class\", \"chart-axis x-axis\");\n\n      function addXGridLines(parentG, glSpec) {\n        if (glSpec.class != undefined) {\n          parentG.classed(glSpec.class, true);\n        }\n        glSpec.values.forEach(function (value) {\n          if (value > spec.xAxis.range.min && value < spec.xAxis.range.max) {\n            parentG.append(\"path\")\n              .attr(\"d\", \"M \" + xMap(value) + \" 0 V \" + spec.chartHeight);\n          }\n        });\n      }\n\n      if (spec.xAxis.gridLines != undefined) {\n        gridLinesG = axisG\n          .append(\"g\")\n          .attr(\"class\", \"grid-lines\");\n        if (spec.xAxis.gridLines instanceof Array) {\n          spec.xAxis.gridLines.forEach(function (glSpec) {\n            addXGridLines(gridLinesG.append(\"g\"), glSpec);\n          });\n        }\n        else {\n          addXGridLines(gridLinesG, spec.xAxis.gridLines);\n        }\n      }\n\n      if (spec.xAxis.labels != undefined) {\n        labelsG = axisG\n          .append(\"g\")\n          .attr(\"class\", \"axis-labels\");\n        spec.xAxis.labels.forEach(function (lvp) {\n          if (lvp.value >= spec.xAxis.range.min && lvp.value <= spec.xAxis.range.max) {\n            var label = labelsG\n              .append(\"text\")\n              .attr(\"x\", xMap(lvp.value))\n              .attr(\"y\", spec.chartHeight + 3)\n              .text(lvp.label);\n            if (lvp.value == spec.xAxis.range.min) {\n              label.classed(\"axis-label-min\", true);\n            }\n            else if (lvp.value == spec.xAxis.range.max) {\n              label.classed(\"axis-label-max\", true);\n            }\n          }\n        });\n      }\n\n      // y-axis:\n      axisG = chartG\n        .append(\"g\")\n        .attr(\"class\", \"chart-axis y-axis\");\n\n      function addYGridLines(parentG, glSpec) {\n        if (glSpec.class != undefined) {\n          parentG.classed(glSpec.class, true);\n        }\n        glSpec.values.forEach(function (value) {\n          if (value > spec.yAxis.range.min && value < spec.yAxis.range.max) {\n            parentG.append(\"path\")\n              .attr(\"d\", \"M 0 \" + yMap(value) + \" H \" + spec.chartWidth);\n          }\n        });\n      }\n\n      if (spec.yAxis.gridLines != undefined) {\n        gridLinesG = axisG\n          .append(\"g\")\n          .attr(\"class\", \"grid-lines\");\n        if (spec.yAxis.gridLines instanceof Array) {\n          spec.yAxis.gridLines.forEach(function (glSpec) {\n            addYGridLines(gridLinesG.append(\"g\"), glSpec);\n          });\n        }\n        else {\n          addYGridLines(gridLinesG, spec.yAxis.gridLines);\n        }\n      }\n\n      if (spec.yAxis.labels != undefined) {\n        labelsG = axisG\n          .append(\"g\")\n          .attr(\"class\", \"axis-labels\");\n        spec.yAxis.labels.forEach(function (lvp) {\n          if (lvp.value >= spec.yAxis.range.min && lvp.value <= spec.yAxis.range.max) {\n            var label = labelsG\n              .append(\"text\")\n              .attr(\"x\", -4)\n              .attr(\"y\", yMap(lvp.value))\n              .text(lvp.label);\n            if (lvp.value == spec.yAxis.range.min) {\n              label.classed(\"axis-label-min\", true);\n            }\n            else if (lvp.value == spec.yAxis.range.max) {\n              label.classed(\"axis-label-max\", true);\n            }\n          }\n        });\n      }\n\n      // chart label:\n      if (spec.title != undefined) {\n        chartG\n          .append(\"text\")\n          .attr(\"class\", \"chart-title\")\n          .attr(\"x\", 4)\n          .attr(\"y\", 4)\n          .text(spec.title.label);\n      }\n\n      // build mapped data:\n      spec.dataSets.forEach(function (dataSet) {\n        dataSet.mapped = dataSet.data.map(function (datum) {\n          return {\n            x: xMap(datum.x),\n            y: yMap(datum.y)\n          }\n        });\n      });\n\n      // plot lines:\n      var dx = function (d) { return d.x; };\n      var dy = function (d) { return d.y; };\n      var plotLine = d3.svg.line().x(dx).y(dy);\n      chartG\n        .append(\"g\")\n        .classed(\"plot-lines\", true)\n        .selectAll(\"path\")\n        .data(spec.dataSets)\n        .enter()\n        .append(\"g\")\n        .classed(\"plot-set\", true)\n        .each(function (ds) {\n          var plotSet = d3.select(this);\n          plotSet\n            .append(\"g\")\n            .classed(\"plot-points\", true)\n            .style(\"fill\", (ds.color != undefined) ? ds.color : null)\n            .selectAll(\"circle\")\n            .data(ds.mapped)\n            .enter()\n            .append(\"circle\")\n            .attr(\"cx\", dx)\n            .attr(\"cy\", dy)\n            .attr(\"r\", \"1.5\");\n          plotSet\n            .append(\"g\")\n            .classed(\"plot-line\", true)\n            .append(\"path\")\n            .attr(\"d\", plotLine(ds.mapped))\n            .style(\"stroke\", (ds.color != undefined) ? ds.color : null);\n        });\n    };\n\n    return lineChart;\n  }\n})();\n","/**\n * Created by wouter on 22/09/2015.\n */\n(function() {\n  'use strict';\n\n  angular.module('enram')\n    .factory('us15a.raw', ['enram', us15a]);\n\n  /**\n   * us15a.raw service constructor.\n   * @returns The service object.\n   */\n  function us15a(enram) {\n    //console.log(\">> us15a.raw factory constructor\");\n\n    var caseStudy = enram.caseStudy(\"us15a\", dataService());\n\n    caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n      return d3.geo.mercator()\n        .scale(caseStudy.mapScaleFactor * mapWidth)\n        .translate([mapWidth / 2, mapHeight / 2])\n        .center(caseStudy.mapCenter);\n    };\n\n    return caseStudy;\n  }\n\n  /**\n   * This data service load the raw data from the raw-data.json file generated\n   * in tipaths_03d/data_work/process_csv_us15a.\n   *\n   * @returns {object}\n   */\n  function dataService() {\n    var dataService = {};\n    var sourceData = null;\n\n    // Raw data indices:\n    var ri_radar = 0,\n      ri_time = 1,\n      ri_strata = 2,\n      ri_uSpeed = 3,\n      ri_vSpeed = 4,\n      ri_density = 5,\n      ri_vertical_integrated_density = 6,\n      ri_number_of_measurements = 7,\n      ri_speed = 8;\n\n    /**\n     * Initializes the dataService.\n     * @param caseStudy {enram.caseStudy}\n     * @param handler\n     */\n    dataService.initialize = function (caseStudy, handler) {\n      caseStudy.label = \"USA, raw\";\n\n      // The implementation expects the records in the data to be temporally sorted.\n      d3.json(caseStudy.urlBase + \"raw-data.json\", function (error, json) {\n        //console.log(caseStudy);\n        if (error) {\n          console.error(error);\n          //throw new Error(\"Error in dataService.loadCaseStudy. \"\n          //    + JSON.parse(error.responseText).error.join(\"; \"));\n          return;\n        }\n\n        sourceData = json;\n        sourceData.forEach(function (rdata) {\n          rdata.forEach(function (sdata) {\n            sdata.forEach(function (record) {\n              record[ri_time] = new Date(record[ri_time]);\n            });\n          });\n        });\n\n        handler();\n      });\n    };\n\n    /**\n     * Loads the data for the given focus.\n     * @param caseStudy {enram.caseStudy}\n     * @param focus     {enram.focus}\n     * @param handler   {function}      called when the data is loaded\n     */\n    dataService.loadFocusData = function (caseStudy, focus, handler) {\n      var data = {\n        focus: focus\n      };\n\n      var times = [];     // dimensions: [strata, radar, time]\n      var densities = []; // dimensions: [strata, radar, time]\n      var speeds = [];    // dimensions: [strata, radar, time]\n\n      var focusFrom = focus.from.toDate();\n      var focusTill = focus.till.toDate();\n      var strn = caseStudy.strataCount;\n      var radn = caseStudy.radarCount;\n\n      for (var stri = 0; stri < strn; stri++) {\n        var timeData = [];\n        var densiData = [];\n        var speedData = [];\n        for (var radi = 0; radi < radn; radi++) {\n          timeData.push(null);\n          densiData.push(null);\n          speedData.push(null);\n        }\n        times.push(timeData);\n        densities.push(densiData);\n        speeds.push(speedData);\n      }\n\n      data.getTimes = function (stri, radi) {\n        var series = times[stri][radi];\n        if (series == null) {\n          series = [];\n          sourceData[radi][stri].forEach(function (record) {\n            var time = record[ri_time];\n            if (time >= focusFrom && time < focusTill) {\n              series.push(time);\n            }\n          });\n          times[stri][radi] = series;\n        }\n        return series;\n      };\n\n      data.getDensities = function (stri, radi) {\n        var series = densities[stri][radi];\n        if (series == null) {\n          series = [];\n          sourceData[radi][stri].forEach(function (record) {\n            var time = record[ri_time];\n            if (time >= focusFrom && time < focusTill) {\n              series.push(record[ri_density]);\n            }\n          });\n          densities[stri][radi] = series;\n        }\n        return series;\n      };\n\n      data.getSpeeds = function (stri, radi) {\n        var series = speeds[stri][radi];\n        if (series == null) {\n          series = [];\n          sourceData[radi][stri].forEach(function (record) {\n            var time = record[ri_time];\n            if (time >= focusFrom && time < focusTill) {\n              series.push(record[ri_speed]);\n            }\n          });\n          speeds[stri][radi] = series;\n        }\n        return series;\n      };\n\n      handler(data);\n    };\n\n    return dataService;\n  }\n\n})();\n","/**\n * Created by wouter on 22/09/2015.\n */\n(function() {\n  'use strict';\n\n  angular.module('enram')\n    .factory('us15a.segmented', ['enram', us15a]);\n\n  /**\n   * us15a.segmented service constructor.\n   * @returns The service object.\n   */\n  function us15a(enram) {\n    //console.log(\">> us15a.segmented factory constructor\");\n\n    var caseStudy = enram.caseStudy(\"us15a\", dataService());\n\n    caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n      return d3.geo.mercator()\n        .scale(caseStudy.mapScaleFactor * mapWidth)\n        .translate([mapWidth / 2, mapHeight / 2])\n        .center(caseStudy.mapCenter);\n    };\n\n    return caseStudy;\n  }\n\n  /**\n   * This service load the TIMAMP data from the data.json file generated\n   * in tipaths_03d/data_work/process_csv_us15a.\n   *\n   * @returns {object}\n   */\n  function dataService() {\n    var dataService = {};\n    var sourceData = null;\n\n    /**\n     * Initializes the dataService.\n     * @param caseStudy {enram.caseStudy}\n     * @param handler {function}\n     */\n    dataService.initialize = function (caseStudy, handler) {\n      caseStudy.label = \"USA, segmented\";\n\n      d3.json(caseStudy.urlBase + \"data.json\", function (error, json) {\n        //console.log(caseStudy);\n        if (error) {\n          console.error(error);\n          //throw new Error(\"Error in dataService.loadCaseStudy. \"\n          //    + JSON.parse(error.responseText).error.join(\"; \"));\n          return;\n        }\n\n        //if (checkData) checkData(sourceData);\n        sourceData = json;\n        handler();\n      });\n    };\n\n    /**\n     * Loads the data for the given focus.\n     * @param caseStudy {enram.caseStudy}\n     * @param focus     {enram.focus}\n     * @param handler   {function(dataObject)} called when the data is loaded\n     */\n    dataService.loadFocusData = function (caseStudy, focus, handler) {\n      //console.log(\">> dataService.loadData()\");\n      var data = {\n        caseStudy: caseStudy,\n        focus: focus\n      };\n\n      var segmentMillis = caseStudy.segmentMillis();\n      var dataFromTime = caseStudy.dataFrom.valueOf();\n      var focusTime = focus.from.valueOf();\n      var dt = focusTime - dataFromTime;\n      var segiFrom = Math.floor(dt / segmentMillis);\n      var segiTill = segiFrom + focus.segmentCount(caseStudy);\n\n      if (segiFrom > caseStudy.segmentCount) {\n        throw new Error(\"Focus outside of source data range\");\n      }\n      if (segiTill < 0) {\n        throw new Error(\"Focus outside of source data range\");\n      }\n      segiFrom = Math.max(segiFrom, 0);\n      segiTill = Math.min(segiTill, caseStudy.segmentCount);\n\n      var times = null;   // dimensions: [time]\n      var densities = []; // dimensions: [strata, radar, time]\n      var speeds = [];    // dimensions: [strata, radar, time]\n\n      var strn = caseStudy.strataCount;\n      var radn = caseStudy.radarCount;\n      var segi;\n      for (var stri = 0; stri < strn; stri++) {\n        var densiData = [];\n        var speedData = [];\n        for (var radi = 0; radi < radn; radi++) {\n          densiData.push(null);\n          speedData.push(null);\n        }\n        densities.push(densiData);\n        speeds.push(speedData);\n      }\n\n      data.getTimes = function (stri, radi) {\n        if (times === null) {\n          times = [];\n          for (var segi = segiFrom; segi < segiTill; segi++) {\n            times.push(dataFromTime + segi * segmentMillis);\n          }\n        }\n        return times;\n      };\n\n      data.getDensities = function (stri, radi) {\n        var series = densities[stri][radi];\n        if (series == null) {\n          series = [];\n          for (segi = segiFrom; segi < segiTill; segi++) {\n            series.push(sourceData.densities[segi][stri][radi]);\n          }\n          densities[stri][radi] = series;\n        }\n        return series;\n      };\n\n      data.getSpeeds = function (stri, radi) {\n        var series = speeds[stri][radi];\n        if (series == null) {\n          series = [];\n          for (segi = segiFrom; segi < segiTill; segi++) {\n            series.push(sourceData.speeds[segi][stri][radi]);\n          }\n          speeds[stri][radi] = series;\n        }\n        return series;\n      };\n\n      handler(data);\n    };\n\n    return dataService;\n  }\n\n})();\n","/**\n * Created by wouter on 22/09/2015.\n */\n(function() {\n  'use strict';\n\n  angular.module('enram')\n    .factory('eu15a', ['enram', 'settings', eu15aFactory]);\n\n  function eu15aFactory(enram, settings) {\n    // case study constructor:\n\n    var caseStudy = enram.caseStudy(\"eu15a\", DBDataServiceInitializer);\n\n    caseStudy.getProjection = function (caseStudy, mapWidth, mapHeight) {\n      return d3.geo.mercator()\n        .scale(caseStudy.mapScaleFactor * mapWidth)\n        .translate([mapWidth / 2, mapHeight / 2])\n        .center(caseStudy.mapCenter);\n    };\n\n    return caseStudy;\n  }\n\n})();\n"],"sourceRoot":"/source/"}